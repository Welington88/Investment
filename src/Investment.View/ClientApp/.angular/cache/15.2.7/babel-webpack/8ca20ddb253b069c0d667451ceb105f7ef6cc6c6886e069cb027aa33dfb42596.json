{"ast":null,"code":"'use strict';\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * @license Angular v<unknown>\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n\n  /**\n   * @fileoverview\n   * @suppress {globalThis}\n   */\n  var NEWLINE = '\\n';\n  var IGNORE_FRAMES = {};\n  var creationTrace = '__creationTrace__';\n  var ERROR_TAG = 'STACKTRACE TRACKING';\n  var SEP_TAG = '__SEP_TAG__';\n  var sepTemplate = SEP_TAG + '@[native]';\n  var LongStackTrace = /** @class */function () {\n    function LongStackTrace() {\n      this.error = getStacktrace();\n      this.timestamp = new Date();\n    }\n    return LongStackTrace;\n  }();\n  function getStacktraceWithUncaughtError() {\n    return new Error(ERROR_TAG);\n  }\n  function getStacktraceWithCaughtError() {\n    try {\n      throw getStacktraceWithUncaughtError();\n    } catch (err) {\n      return err;\n    }\n  }\n  // Some implementations of exception handling don't create a stack trace if the exception\n  // isn't thrown, however it's faster not to actually throw the exception.\n  var error = getStacktraceWithUncaughtError();\n  var caughtError = getStacktraceWithCaughtError();\n  var getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;\n  function getFrames(error) {\n    return error.stack ? error.stack.split(NEWLINE) : [];\n  }\n  function addErrorStack(lines, error) {\n    var trace = getFrames(error);\n    for (var i = 0; i < trace.length; i++) {\n      var frame = trace[i];\n      // Filter out the Frames which are part of stack capturing.\n      if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n        lines.push(trace[i]);\n      }\n    }\n  }\n  function renderLongStackTrace(frames, stack) {\n    var longTrace = [stack ? stack.trim() : ''];\n    if (frames) {\n      var timestamp = new Date().getTime();\n      for (var i = 0; i < frames.length; i++) {\n        var traceFrames = frames[i];\n        var lastTime = traceFrames.timestamp;\n        var separator = \"____________________Elapsed \".concat(timestamp - lastTime.getTime(), \" ms; At: \").concat(lastTime);\n        separator = separator.replace(/[^\\w\\d]/g, '_');\n        longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n        addErrorStack(longTrace, traceFrames.error);\n        timestamp = lastTime.getTime();\n      }\n    }\n    return longTrace.join(NEWLINE);\n  }\n  // if Error.stackTraceLimit is 0, means stack trace\n  // is disabled, so we don't need to generate long stack trace\n  // this will improve performance in some test(some test will\n  // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n  function stackTracesEnabled() {\n    // Cast through any since this property only exists on Error in the nodejs\n    // typings.\n    return Error.stackTraceLimit > 0;\n  }\n  Zone['longStackTraceZoneSpec'] = {\n    name: 'long-stack-trace',\n    longStackTraceLimit: 10,\n    // add a getLongStackTrace method in spec to\n    // handle handled reject promise error.\n    getLongStackTrace: function (error) {\n      if (!error) {\n        return undefined;\n      }\n      var trace = error[Zone.__symbol__('currentTaskTrace')];\n      if (!trace) {\n        return error.stack;\n      }\n      return renderLongStackTrace(trace, error.stack);\n    },\n    onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (stackTracesEnabled()) {\n        var currentTask = Zone.currentTask;\n        var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n        trace = [new LongStackTrace()].concat(trace);\n        if (trace.length > this.longStackTraceLimit) {\n          trace.length = this.longStackTraceLimit;\n        }\n        if (!task.data) task.data = {};\n        if (task.type === 'eventTask') {\n          // Fix issue https://github.com/angular/zone.js/issues/1195,\n          // For event task of browser, by default, all task will share a\n          // singleton instance of data object, we should create a new one here\n          // The cast to `any` is required to workaround a closure bug which wrongly applies\n          // URL sanitization rules to .data access.\n          task.data = __assign({}, task.data);\n        }\n        task.data[creationTrace] = trace;\n      }\n      return parentZoneDelegate.scheduleTask(targetZone, task);\n    },\n    onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n      if (stackTracesEnabled()) {\n        var parentTask = Zone.currentTask || error.task;\n        if (error instanceof Error && parentTask) {\n          var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n          try {\n            error.stack = error.longStack = longStack;\n          } catch (err) {}\n        }\n      }\n      return parentZoneDelegate.handleError(targetZone, error);\n    }\n  };\n  function captureStackTraces(stackTraces, count) {\n    if (count > 0) {\n      stackTraces.push(getFrames(new LongStackTrace().error));\n      captureStackTraces(stackTraces, count - 1);\n    }\n  }\n  function computeIgnoreFrames() {\n    if (!stackTracesEnabled()) {\n      return;\n    }\n    var frames = [];\n    captureStackTraces(frames, 2);\n    var frames1 = frames[0];\n    var frames2 = frames[1];\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n      if (frame1.indexOf(ERROR_TAG) == -1) {\n        var match = frame1.match(/^\\s*at\\s+/);\n        if (match) {\n          sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n          break;\n        }\n      }\n    }\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n      var frame2 = frames2[i];\n      if (frame1 === frame2) {\n        IGNORE_FRAMES[frame1] = true;\n      } else {\n        break;\n      }\n    }\n  }\n  computeIgnoreFrames();\n  var ProxyZoneSpec = /** @class */function () {\n    function ProxyZoneSpec(defaultSpecDelegate) {\n      if (defaultSpecDelegate === void 0) {\n        defaultSpecDelegate = null;\n      }\n      this.defaultSpecDelegate = defaultSpecDelegate;\n      this.name = 'ProxyZone';\n      this._delegateSpec = null;\n      this.properties = {\n        'ProxyZoneSpec': this\n      };\n      this.propertyKeys = null;\n      this.lastTaskState = null;\n      this.isNeedToTriggerHasTask = false;\n      this.tasks = [];\n      this.setDelegate(defaultSpecDelegate);\n    }\n    ProxyZoneSpec.get = function () {\n      return Zone.current.get('ProxyZoneSpec');\n    };\n    ProxyZoneSpec.isLoaded = function () {\n      return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n    };\n    ProxyZoneSpec.assertPresent = function () {\n      if (!ProxyZoneSpec.isLoaded()) {\n        throw new Error(\"Expected to be running in 'ProxyZone', but it was not found.\");\n      }\n      return ProxyZoneSpec.get();\n    };\n    ProxyZoneSpec.prototype.setDelegate = function (delegateSpec) {\n      var _this = this;\n      var isNewDelegate = this._delegateSpec !== delegateSpec;\n      this._delegateSpec = delegateSpec;\n      this.propertyKeys && this.propertyKeys.forEach(function (key) {\n        return delete _this.properties[key];\n      });\n      this.propertyKeys = null;\n      if (delegateSpec && delegateSpec.properties) {\n        this.propertyKeys = Object.keys(delegateSpec.properties);\n        this.propertyKeys.forEach(function (k) {\n          return _this.properties[k] = delegateSpec.properties[k];\n        });\n      }\n      // if a new delegateSpec was set, check if we need to trigger hasTask\n      if (isNewDelegate && this.lastTaskState && (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n        this.isNeedToTriggerHasTask = true;\n      }\n    };\n    ProxyZoneSpec.prototype.getDelegate = function () {\n      return this._delegateSpec;\n    };\n    ProxyZoneSpec.prototype.resetDelegate = function () {\n      this.getDelegate();\n      this.setDelegate(this.defaultSpecDelegate);\n    };\n    ProxyZoneSpec.prototype.tryTriggerHasTask = function (parentZoneDelegate, currentZone, targetZone) {\n      if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n        // last delegateSpec has microTask or macroTask\n        // should call onHasTask in current delegateSpec\n        this.isNeedToTriggerHasTask = false;\n        this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n      }\n    };\n    ProxyZoneSpec.prototype.removeFromTasks = function (task) {\n      if (!this.tasks) {\n        return;\n      }\n      for (var i = 0; i < this.tasks.length; i++) {\n        if (this.tasks[i] === task) {\n          this.tasks.splice(i, 1);\n          return;\n        }\n      }\n    };\n    ProxyZoneSpec.prototype.getAndClearPendingTasksInfo = function () {\n      if (this.tasks.length === 0) {\n        return '';\n      }\n      var taskInfo = this.tasks.map(function (task) {\n        var dataInfo = task.data && Object.keys(task.data).map(function (key) {\n          return key + ':' + task.data[key];\n        }).join(',');\n        return \"type: \".concat(task.type, \", source: \").concat(task.source, \", args: {\").concat(dataInfo, \"}\");\n      });\n      var pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']';\n      // clear tasks\n      this.tasks = [];\n      return pendingTasksInfo;\n    };\n    ProxyZoneSpec.prototype.onFork = function (parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n      if (this._delegateSpec && this._delegateSpec.onFork) {\n        return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n      } else {\n        return parentZoneDelegate.fork(targetZone, zoneSpec);\n      }\n    };\n    ProxyZoneSpec.prototype.onIntercept = function (parentZoneDelegate, currentZone, targetZone, delegate, source) {\n      if (this._delegateSpec && this._delegateSpec.onIntercept) {\n        return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n      } else {\n        return parentZoneDelegate.intercept(targetZone, delegate, source);\n      }\n    };\n    ProxyZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n      if (this._delegateSpec && this._delegateSpec.onInvoke) {\n        return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n      } else {\n        return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n      }\n    };\n    ProxyZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n      if (this._delegateSpec && this._delegateSpec.onHandleError) {\n        return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n      } else {\n        return parentZoneDelegate.handleError(targetZone, error);\n      }\n    };\n    ProxyZoneSpec.prototype.onScheduleTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (task.type !== 'eventTask') {\n        this.tasks.push(task);\n      }\n      if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n        return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n      } else {\n        return parentZoneDelegate.scheduleTask(targetZone, task);\n      }\n    };\n    ProxyZoneSpec.prototype.onInvokeTask = function (parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n      if (task.type !== 'eventTask') {\n        this.removeFromTasks(task);\n      }\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n      if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n        return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n      } else {\n        return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n      }\n    };\n    ProxyZoneSpec.prototype.onCancelTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (task.type !== 'eventTask') {\n        this.removeFromTasks(task);\n      }\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n      if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n        return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n      } else {\n        return parentZoneDelegate.cancelTask(targetZone, task);\n      }\n    };\n    ProxyZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n      this.lastTaskState = hasTaskState;\n      if (this._delegateSpec && this._delegateSpec.onHasTask) {\n        this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n      } else {\n        delegate.hasTask(target, hasTaskState);\n      }\n    };\n    return ProxyZoneSpec;\n  }();\n  // Export the class so that new instances can be created with proper\n  // constructor params.\n  Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n  var SyncTestZoneSpec = /** @class */function () {\n    function SyncTestZoneSpec(namePrefix) {\n      this.runZone = Zone.current;\n      this.name = 'syncTestZone for ' + namePrefix;\n    }\n    SyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n      switch (task.type) {\n        case 'microTask':\n        case 'macroTask':\n          throw new Error(\"Cannot call \".concat(task.source, \" from within a sync test (\").concat(this.name, \").\"));\n        case 'eventTask':\n          task = delegate.scheduleTask(target, task);\n          break;\n      }\n      return task;\n    };\n    return SyncTestZoneSpec;\n  }();\n  // Export the class so that new instances can be created with proper\n  // constructor params.\n  Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n  /// <reference types=\"jasmine\"/>\n  Zone.__load_patch('jasmine', function (global, Zone, api) {\n    var __extends = function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() {\n        this.constructor = d;\n      }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n    // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n    if (!Zone) throw new Error('Missing: zone.js');\n    if (typeof jest !== 'undefined') {\n      // return if jasmine is a light implementation inside jest\n      // in this case, we are running inside jest not jasmine\n      return;\n    }\n    if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n      return;\n    }\n    jasmine['__zone_patch__'] = true;\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (!SyncTestZoneSpec) throw new Error('Missing: SyncTestZoneSpec');\n    if (!ProxyZoneSpec) throw new Error('Missing: ProxyZoneSpec');\n    var ambientZone = Zone.current;\n    var symbol = Zone.__symbol__;\n    // whether patch jasmine clock when in fakeAsync\n    var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n    // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n    // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n    // automatically disable the auto jump into fakeAsync feature\n    var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global[symbol('fakeAsyncPatchLock')] === true || global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n    var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n    if (!ignoreUnhandledRejection) {\n      var globalErrors_1 = jasmine.GlobalErrors;\n      if (globalErrors_1 && !jasmine[symbol('GlobalErrors')]) {\n        jasmine[symbol('GlobalErrors')] = globalErrors_1;\n        jasmine.GlobalErrors = function () {\n          var instance = new globalErrors_1();\n          var originalInstall = instance.install;\n          if (originalInstall && !instance[symbol('install')]) {\n            instance[symbol('install')] = originalInstall;\n            instance.install = function () {\n              var isNode = typeof process !== 'undefined' && !!process.on;\n              // Note: Jasmine checks internally if `process` and `process.on` is defined. Otherwise,\n              // it installs the browser rejection handler through the `global.addEventListener`.\n              // This code may be run in the browser environment where `process` is not defined, and\n              // this will lead to a runtime exception since Webpack 5 removed automatic Node.js\n              // polyfills. Note, that events are named differently, it's `unhandledRejection` in\n              // Node.js and `unhandledrejection` in the browser.\n              var originalHandlers = isNode ? process.listeners('unhandledRejection') : global.eventListeners('unhandledrejection');\n              var result = originalInstall.apply(this, arguments);\n              isNode ? process.removeAllListeners('unhandledRejection') : global.removeAllListeners('unhandledrejection');\n              if (originalHandlers) {\n                originalHandlers.forEach(function (handler) {\n                  if (isNode) {\n                    process.on('unhandledRejection', handler);\n                  } else {\n                    global.addEventListener('unhandledrejection', handler);\n                  }\n                });\n              }\n              return result;\n            };\n          }\n          return instance;\n        };\n      }\n    }\n    // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n    var jasmineEnv = jasmine.getEnv();\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[methodName] = function (description, specDefinitions) {\n        return originalJasmineFn.call(this, description, wrapDescribeInZone(description, specDefinitions));\n      };\n    });\n    ['it', 'xit', 'fit'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n      jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n        arguments[1] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n      jasmineEnv[methodName] = function (specDefinitions, timeout) {\n        arguments[0] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n    if (!disablePatchingJasmineClock) {\n      // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n      // they can work properly in FakeAsyncTest\n      var originalClockFn_1 = jasmine[symbol('clock')] = jasmine['clock'];\n      jasmine['clock'] = function () {\n        var clock = originalClockFn_1.apply(this, arguments);\n        if (!clock[symbol('patched')]) {\n          clock[symbol('patched')] = symbol('patched');\n          var originalTick_1 = clock[symbol('tick')] = clock.tick;\n          clock.tick = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n            if (fakeAsyncZoneSpec) {\n              return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n            }\n            return originalTick_1.apply(this, arguments);\n          };\n          var originalMockDate_1 = clock[symbol('mockDate')] = clock.mockDate;\n          clock.mockDate = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n            if (fakeAsyncZoneSpec) {\n              var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n              return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] : arguments);\n            }\n            return originalMockDate_1.apply(this, arguments);\n          };\n          // for auto go into fakeAsync feature, we need the flag to enable it\n          if (enableAutoFakeAsyncWhenClockPatched) {\n            ['install', 'uninstall'].forEach(function (methodName) {\n              var originalClockFn = clock[symbol(methodName)] = clock[methodName];\n              clock[methodName] = function () {\n                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n                if (FakeAsyncTestZoneSpec) {\n                  jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                  return;\n                }\n                return originalClockFn.apply(this, arguments);\n              };\n            });\n          }\n        }\n        return clock;\n      };\n    }\n    // monkey patch createSpyObj to make properties enumerable to true\n    if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n      var originalCreateSpyObj_1 = jasmine.createSpyObj;\n      jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj_1;\n      jasmine.createSpyObj = function () {\n        var args = Array.prototype.slice.call(arguments);\n        var propertyNames = args.length >= 3 ? args[2] : null;\n        var spyObj;\n        if (propertyNames) {\n          var defineProperty_1 = Object.defineProperty;\n          Object.defineProperty = function (obj, p, attributes) {\n            return defineProperty_1.call(this, obj, p, __assign(__assign({}, attributes), {\n              configurable: true,\n              enumerable: true\n            }));\n          };\n          try {\n            spyObj = originalCreateSpyObj_1.apply(this, args);\n          } finally {\n            Object.defineProperty = defineProperty_1;\n          }\n        } else {\n          spyObj = originalCreateSpyObj_1.apply(this, args);\n        }\n        return spyObj;\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n     * synchronous-only zone.\n     */\n    function wrapDescribeInZone(description, describeBody) {\n      return function () {\n        // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n        // error if any asynchronous operations are attempted inside of a `describe`.\n        var syncZone = ambientZone.fork(new SyncTestZoneSpec(\"jasmine.describe#\".concat(description)));\n        return syncZone.run(describeBody, this, arguments);\n      };\n    }\n    function runInTestZone(testBody, applyThis, queueRunner, done) {\n      var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n      queueRunner.testProxyZoneSpec;\n      var testProxyZone = queueRunner.testProxyZone;\n      if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n        // auto run a fakeAsync\n        var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n          testBody = fakeAsyncModule.fakeAsync(testBody);\n        }\n      }\n      if (done) {\n        return testProxyZone.run(testBody, applyThis, [done]);\n      } else {\n        return testProxyZone.run(testBody, applyThis);\n      }\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n     */\n    function wrapTestInZone(testBody) {\n      // The `done` callback is only passed through if the function expects at least one argument.\n      // Note we have to make a function with correct number of arguments, otherwise jasmine will\n      // think that all functions are sync or async.\n      return testBody && (testBody.length ? function (done) {\n        return runInTestZone(testBody, this, this.queueRunner, done);\n      } : function () {\n        return runInTestZone(testBody, this, this.queueRunner);\n      });\n    }\n    var QueueRunner = jasmine.QueueRunner;\n    jasmine.QueueRunner = function (_super) {\n      __extends(ZoneQueueRunner, _super);\n      function ZoneQueueRunner(attrs) {\n        var _this = this;\n        if (attrs.onComplete) {\n          attrs.onComplete = function (fn) {\n            return function () {\n              // All functions are done, clear the test zone.\n              _this.testProxyZone = null;\n              _this.testProxyZoneSpec = null;\n              ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n            };\n          }(attrs.onComplete);\n        }\n        var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n        var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n        if (nativeSetTimeout) {\n          // should run setTimeout inside jasmine outside of zone\n          attrs.timeout = {\n            setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n            clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n          };\n        }\n        // create a userContext to hold the queueRunner itself\n        // so we can access the testProxy in it/xit/beforeEach ...\n        if (jasmine.UserContext) {\n          if (!attrs.userContext) {\n            attrs.userContext = new jasmine.UserContext();\n          }\n          attrs.userContext.queueRunner = this;\n        } else {\n          if (!attrs.userContext) {\n            attrs.userContext = {};\n          }\n          attrs.userContext.queueRunner = this;\n        }\n        // patch attrs.onException\n        var onException = attrs.onException;\n        attrs.onException = function (error) {\n          if (error && error.message === 'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n            // jasmine timeout, we can make the error message more\n            // reasonable to tell what tasks are pending\n            var proxyZoneSpec = this && this.testProxyZoneSpec;\n            if (proxyZoneSpec) {\n              var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n              try {\n                // try catch here in case error.message is not writable\n                error.message += pendingTasksInfo;\n              } catch (err) {}\n            }\n          }\n          if (onException) {\n            onException.call(this, error);\n          }\n        };\n        _super.call(this, attrs);\n      }\n      ZoneQueueRunner.prototype.execute = function () {\n        var _this = this;\n        var zone = Zone.current;\n        var isChildOfAmbientZone = false;\n        while (zone) {\n          if (zone === ambientZone) {\n            isChildOfAmbientZone = true;\n            break;\n          }\n          zone = zone.parent;\n        }\n        if (!isChildOfAmbientZone) throw new Error('Unexpected Zone: ' + Zone.current.name);\n        // This is the zone which will be used for running individual tests.\n        // It will be a proxy zone, so that the tests function can retroactively install\n        // different zones.\n        // Example:\n        //   - In beforeEach() do childZone = Zone.current.fork(...);\n        //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n        //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n        //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n        //     fakeAsync behavior to the childZone.\n        this.testProxyZoneSpec = new ProxyZoneSpec();\n        this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n        if (!Zone.currentTask) {\n          // if we are not running in a task then if someone would register a\n          // element.addEventListener and then calling element.click() the\n          // addEventListener callback would think that it is the top most task and would\n          // drain the microtask queue on element.click() which would be incorrect.\n          // For this reason we always force a task when running jasmine tests.\n          Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () {\n            return QueueRunner.prototype.execute.call(_this);\n          });\n        } else {\n          _super.prototype.execute.call(this);\n        }\n      };\n      return ZoneQueueRunner;\n    }(QueueRunner);\n  });\n  Zone.__load_patch('jest', function (context, Zone, api) {\n    if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n      return;\n    }\n    jest['__zone_patch__'] = true;\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    if (!ProxyZoneSpec) {\n      throw new Error('Missing ProxyZoneSpec');\n    }\n    var rootZone = Zone.current;\n    var syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n    var proxyZoneSpec = new ProxyZoneSpec();\n    var proxyZone = rootZone.fork(proxyZoneSpec);\n    function wrapDescribeFactoryInZone(originalJestFn) {\n      return function () {\n        var tableArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          tableArgs[_i] = arguments[_i];\n        }\n        var originalDescribeFn = originalJestFn.apply(this, tableArgs);\n        return function () {\n          var args = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n          args[1] = wrapDescribeInZone(args[1]);\n          return originalDescribeFn.apply(this, args);\n        };\n      };\n    }\n    function wrapTestFactoryInZone(originalJestFn) {\n      return function () {\n        var tableArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          tableArgs[_i] = arguments[_i];\n        }\n        return function () {\n          var args = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n          args[1] = wrapTestInZone(args[1]);\n          return originalJestFn.apply(this, tableArgs).apply(this, args);\n        };\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `describe` block to execute in a\n     * synchronous-only zone.\n     */\n    function wrapDescribeInZone(describeBody) {\n      return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        return syncZone.run(describeBody, this, args);\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in the `proxyZone`.\n     */\n    function wrapTestInZone(testBody, isTestFunc) {\n      if (isTestFunc === void 0) {\n        isTestFunc = false;\n      }\n      if (typeof testBody !== 'function') {\n        return testBody;\n      }\n      var wrappedFunc = function () {\n        if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody && !testBody.isFakeAsync) {\n          // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n          var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n          if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n            testBody = fakeAsyncModule.fakeAsync(testBody);\n          }\n        }\n        proxyZoneSpec.isTestFunc = isTestFunc;\n        return proxyZone.run(testBody, null, arguments);\n      };\n      // Update the length of wrappedFunc to be the same as the length of the testBody\n      // So jest core can handle whether the test function has `done()` or not correctly\n      Object.defineProperty(wrappedFunc, 'length', {\n        configurable: true,\n        writable: true,\n        enumerable: false\n      });\n      wrappedFunc.length = testBody.length;\n      return wrappedFunc;\n    }\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n      context[methodName] = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        args[1] = wrapDescribeInZone(args[1]);\n        return originalJestFn.apply(this, args);\n      };\n      context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n    });\n    context.describe.only = context.fdescribe;\n    context.describe.skip = context.xdescribe;\n    ['it', 'xit', 'fit', 'test', 'xtest'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n      context[methodName] = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        args[1] = wrapTestInZone(args[1], true);\n        return originalJestFn.apply(this, args);\n      };\n      context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n      context[methodName].todo = originalJestFn.todo;\n    });\n    context.it.only = context.fit;\n    context.it.skip = context.xit;\n    context.test.only = context.fit;\n    context.test.skip = context.xit;\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n      context[methodName] = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        args[0] = wrapTestInZone(args[0]);\n        return originalJestFn.apply(this, args);\n      };\n    });\n    Zone.patchJestObject = function patchJestObject(Timer, isModern) {\n      if (isModern === void 0) {\n        isModern = false;\n      }\n      // check whether currently the test is inside fakeAsync()\n      function isPatchingFakeTimer() {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        return !!fakeAsyncZoneSpec;\n      }\n      // check whether the current function is inside `test/it` or other methods\n      // such as `describe/beforeEach`\n      function isInTestFunc() {\n        var proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n        return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n      }\n      if (Timer[api.symbol('fakeTimers')]) {\n        return;\n      }\n      Timer[api.symbol('fakeTimers')] = true;\n      // patch jest fakeTimer internal method to make sure no console.warn print out\n      api.patchMethod(Timer, '_checkFakeTimers', function (delegate) {\n        return function (self, args) {\n          if (isPatchingFakeTimer()) {\n            return true;\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n      // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n      api.patchMethod(Timer, 'useFakeTimers', function (delegate) {\n        return function (self, args) {\n          Zone[api.symbol('useFakeTimersCalled')] = true;\n          if (isModern || isInTestFunc()) {\n            return delegate.apply(self, args);\n          }\n          return self;\n        };\n      });\n      // patch useRealTimers(), unset useFakeTimers flag\n      api.patchMethod(Timer, 'useRealTimers', function (delegate) {\n        return function (self, args) {\n          Zone[api.symbol('useFakeTimersCalled')] = false;\n          if (isModern || isInTestFunc()) {\n            return delegate.apply(self, args);\n          }\n          return self;\n        };\n      });\n      // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n      api.patchMethod(Timer, 'setSystemTime', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n          if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n            fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n      // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n      api.patchMethod(Timer, 'getRealSystemTime', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n          if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n            return fakeAsyncZoneSpec.getRealSystemTime();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n      // patch runAllTicks(), run all microTasks inside fakeAsync\n      api.patchMethod(Timer, 'runAllTicks', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.flushMicrotasks();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n      // patch runAllTimers(), run all macroTasks inside fakeAsync\n      api.patchMethod(Timer, 'runAllTimers', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.flush(100, true);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n      // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n      api.patchMethod(Timer, 'advanceTimersByTime', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.tick(args[0]);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n      // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n      api.patchMethod(Timer, 'runOnlyPendingTimers', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.flushOnlyPendingTimers();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n      // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n      api.patchMethod(Timer, 'advanceTimersToNextTimer', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.tickToNext(args[0]);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n      // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n      api.patchMethod(Timer, 'clearAllTimers', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.removeAllTimers();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n      // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n      api.patchMethod(Timer, 'getTimerCount', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n          if (fakeAsyncZoneSpec) {\n            return fakeAsyncZoneSpec.getTimerCount();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n    };\n  });\n  Zone.__load_patch('mocha', function (global, Zone) {\n    var Mocha = global.Mocha;\n    if (typeof Mocha === 'undefined') {\n      // return if Mocha is not available, because now zone-testing\n      // will load mocha patch with jasmine/jest patch\n      return;\n    }\n    if (typeof Zone === 'undefined') {\n      throw new Error('Missing Zone.js');\n    }\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    if (!ProxyZoneSpec) {\n      throw new Error('Missing ProxyZoneSpec');\n    }\n    if (Mocha['__zone_patch__']) {\n      throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n    }\n    Mocha['__zone_patch__'] = true;\n    var rootZone = Zone.current;\n    var syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n    var testZone = null;\n    var suiteZone = rootZone.fork(new ProxyZoneSpec());\n    var mochaOriginal = {\n      after: global.after,\n      afterEach: global.afterEach,\n      before: global.before,\n      beforeEach: global.beforeEach,\n      describe: global.describe,\n      it: global.it\n    };\n    function modifyArguments(args, syncTest, asyncTest) {\n      var _loop_1 = function (i) {\n        var arg = args[i];\n        if (typeof arg === 'function') {\n          // The `done` callback is only passed through if the function expects at\n          // least one argument.\n          // Note we have to make a function with correct number of arguments,\n          // otherwise mocha will\n          // think that all functions are sync or async.\n          args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg);\n          // Mocha uses toString to view the test body in the result list, make sure we return the\n          // correct function body\n          args[i].toString = function () {\n            return arg.toString();\n          };\n        }\n      };\n      for (var i = 0; i < args.length; i++) {\n        _loop_1(i);\n      }\n      return args;\n    }\n    function wrapDescribeInZone(args) {\n      var syncTest = function (fn) {\n        return function () {\n          return syncZone.run(fn, this, arguments);\n        };\n      };\n      return modifyArguments(args, syncTest);\n    }\n    function wrapTestInZone(args) {\n      var asyncTest = function (fn) {\n        return function (done) {\n          return testZone.run(fn, this, [done]);\n        };\n      };\n      var syncTest = function (fn) {\n        return function () {\n          return testZone.run(fn, this);\n        };\n      };\n      return modifyArguments(args, syncTest, asyncTest);\n    }\n    function wrapSuiteInZone(args) {\n      var asyncTest = function (fn) {\n        return function (done) {\n          return suiteZone.run(fn, this, [done]);\n        };\n      };\n      var syncTest = function (fn) {\n        return function () {\n          return suiteZone.run(fn, this);\n        };\n      };\n      return modifyArguments(args, syncTest, asyncTest);\n    }\n    global.describe = global.suite = function () {\n      return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n    };\n    global.xdescribe = global.suite.skip = function () {\n      return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n    };\n    global.describe.only = global.suite.only = function () {\n      return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n    };\n    global.it = global.specify = global.test = function () {\n      return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n    };\n    global.xit = global.xspecify = function () {\n      return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n    };\n    global.it.only = global.test.only = function () {\n      return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n    };\n    global.after = global.suiteTeardown = function () {\n      return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n    };\n    global.afterEach = global.teardown = function () {\n      return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n    };\n    global.before = global.suiteSetup = function () {\n      return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n    };\n    global.beforeEach = global.setup = function () {\n      return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n    };\n    (function (originalRunTest, originalRun) {\n      Mocha.Runner.prototype.runTest = function (fn) {\n        var _this = this;\n        Zone.current.scheduleMicroTask('mocha.forceTask', function () {\n          originalRunTest.call(_this, fn);\n        });\n      };\n      Mocha.Runner.prototype.run = function (fn) {\n        this.on('test', function (e) {\n          testZone = rootZone.fork(new ProxyZoneSpec());\n        });\n        this.on('fail', function (test, err) {\n          var proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n          if (proxyZoneSpec && err) {\n            try {\n              // try catch here in case err.message is not writable\n              err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n            } catch (error) {}\n          }\n        });\n        return originalRun.call(this, fn);\n      };\n    })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n  });\n  (function (_global) {\n    var AsyncTestZoneSpec = /** @class */function () {\n      function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n        this.finishCallback = finishCallback;\n        this.failCallback = failCallback;\n        this._pendingMicroTasks = false;\n        this._pendingMacroTasks = false;\n        this._alreadyErrored = false;\n        this._isSync = false;\n        this._existingFinishTimer = null;\n        this.entryFunction = null;\n        this.runZone = Zone.current;\n        this.unresolvedChainedPromiseCount = 0;\n        this.supportWaitUnresolvedChainedPromise = false;\n        this.name = 'asyncTestZone for ' + namePrefix;\n        this.properties = {\n          'AsyncTestZoneSpec': this\n        };\n        this.supportWaitUnresolvedChainedPromise = _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n      }\n      AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {\n        return this.unresolvedChainedPromiseCount > 0;\n      };\n      AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n        var _this = this;\n        // NOTE: Technically the `onHasTask` could fire together with the initial synchronous\n        // completion in `onInvoke`. `onHasTask` might call this method when it captured e.g.\n        // microtasks in the proxy zone that now complete as part of this async zone run.\n        // Consider the following scenario:\n        //    1. A test `beforeEach` schedules a microtask in the ProxyZone.\n        //    2. An actual empty `it` spec executes in the AsyncTestZone` (using e.g. `waitForAsync`).\n        //    3. The `onInvoke` invokes `_finishCallbackIfDone` because the spec runs synchronously.\n        //    4. We wait the scheduled timeout (see below) to account for unhandled promises.\n        //    5. The microtask from (1) finishes and `onHasTask` is invoked.\n        //    --> We register a second `_finishCallbackIfDone` even though we have scheduled a timeout.\n        // If the finish timeout from below is already scheduled, terminate the existing scheduled\n        // finish invocation, avoiding calling `jasmine` `done` multiple times. *Note* that we would\n        // want to schedule a new finish callback in case the task state changes again.\n        if (this._existingFinishTimer !== null) {\n          clearTimeout(this._existingFinishTimer);\n          this._existingFinishTimer = null;\n        }\n        if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {\n          // We wait until the next tick because we would like to catch unhandled promises which could\n          // cause test logic to be executed. In such cases we cannot finish with tasks pending then.\n          this.runZone.run(function () {\n            _this._existingFinishTimer = setTimeout(function () {\n              if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                _this.finishCallback();\n              }\n            }, 0);\n          });\n        }\n      };\n      AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n        var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n        if (patchPromiseForTest) {\n          patchPromiseForTest();\n        }\n      };\n      AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n        var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n        if (unPatchPromiseForTest) {\n          unPatchPromiseForTest();\n        }\n      };\n      AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n        if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n          // check whether the promise is a chained promise\n          if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n            // chained promise is being scheduled\n            this.unresolvedChainedPromiseCount--;\n          }\n        }\n        return delegate.scheduleTask(target, task);\n      };\n      AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      };\n      AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n        return delegate.cancelTask(target, task);\n      };\n      // Note - we need to use onInvoke at the moment to call finish when a test is\n      // fully synchronous. TODO(juliemr): remove this when the logic for\n      // onHasTask changes and it calls whenever the task queues are dirty.\n      // updated by(JiaLiPassion), only call finish callback when no task\n      // was scheduled/invoked/canceled.\n      AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        if (!this.entryFunction) {\n          this.entryFunction = delegate;\n        }\n        try {\n          this._isSync = true;\n          return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        } finally {\n          // We need to check the delegate is the same as entryFunction or not.\n          // Consider the following case.\n          //\n          // asyncTestZone.run(() => { // Here the delegate will be the entryFunction\n          //   Zone.current.run(() => { // Here the delegate will not be the entryFunction\n          //   });\n          // });\n          //\n          // We only want to check whether there are async tasks scheduled\n          // for the entry function.\n          if (this._isSync && this.entryFunction === delegate) {\n            this._finishCallbackIfDone();\n          }\n        }\n      };\n      AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        // Let the parent try to handle the error.\n        var result = parentZoneDelegate.handleError(targetZone, error);\n        if (result) {\n          this.failCallback(error);\n          this._alreadyErrored = true;\n        }\n        return false;\n      };\n      AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n        delegate.hasTask(target, hasTaskState);\n        // We should only trigger finishCallback when the target zone is the AsyncTestZone\n        // Consider the following cases.\n        //\n        // const childZone = asyncTestZone.fork({\n        //   name: 'child',\n        //   onHasTask: ...\n        // });\n        //\n        // So we have nested zones declared the onHasTask hook, in this case,\n        // the onHasTask will be triggered twice, and cause the finishCallbackIfDone()\n        // is also be invoked twice. So we need to only trigger the finishCallbackIfDone()\n        // when the current zone is the same as the target zone.\n        if (current !== target) {\n          return;\n        }\n        if (hasTaskState.change == 'microTask') {\n          this._pendingMicroTasks = hasTaskState.microTask;\n          this._finishCallbackIfDone();\n        } else if (hasTaskState.change == 'macroTask') {\n          this._pendingMacroTasks = hasTaskState.macroTask;\n          this._finishCallbackIfDone();\n        }\n      };\n      return AsyncTestZoneSpec;\n    }();\n    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n  })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n  Zone.__load_patch('asynctest', function (global, Zone, api) {\n    /**\n     * Wraps a test function in an asynchronous test zone. The test will automatically\n     * complete when all asynchronous calls within this zone are done.\n     */\n    Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n      // If we're running using the Jasmine test framework, adapt to call the 'done'\n      // function when asynchronous activity is finished.\n      if (global.jasmine) {\n        // Not using an arrow function to preserve context passed from call site\n        return function (done) {\n          if (!done) {\n            // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n            // fake it here and assume sync.\n            done = function () {};\n            done.fail = function (e) {\n              throw e;\n            };\n          }\n          runInTestZone(fn, this, done, function (err) {\n            if (typeof err === 'string') {\n              return done.fail(new Error(err));\n            } else {\n              done.fail(err);\n            }\n          });\n        };\n      }\n      // Otherwise, return a promise which will resolve when asynchronous activity\n      // is finished. This will be correctly consumed by the Mocha framework with\n      // it('...', async(myFn)); or can be used in a custom framework.\n      // Not using an arrow function to preserve context passed from call site\n      return function () {\n        var _this = this;\n        return new Promise(function (finishCallback, failCallback) {\n          runInTestZone(fn, _this, finishCallback, failCallback);\n        });\n      };\n    };\n    function runInTestZone(fn, context, finishCallback, failCallback) {\n      var currentZone = Zone.current;\n      var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n      if (AsyncTestZoneSpec === undefined) {\n        throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/async-test');\n      }\n      var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n      if (!ProxyZoneSpec) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/proxy');\n      }\n      var proxyZoneSpec = ProxyZoneSpec.get();\n      ProxyZoneSpec.assertPresent();\n      // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n      // If we do it in ProxyZone then we will get to infinite recursion.\n      var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n      var previousDelegate = proxyZoneSpec.getDelegate();\n      proxyZone.parent.run(function () {\n        var testZoneSpec = new AsyncTestZoneSpec(function () {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's\n            // still this one. Otherwise, assume\n            // it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            finishCallback();\n          });\n        }, function (error) {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            failCallback(error);\n          });\n        }, 'test');\n        proxyZoneSpec.setDelegate(testZoneSpec);\n        testZoneSpec.patchPromiseForTest();\n      });\n      return Zone.current.runGuarded(fn, context);\n    }\n  });\n  (function (global) {\n    var OriginalDate = global.Date;\n    // Since when we compile this file to `es2015`, and if we define\n    // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n    // there will be an error which is `Cannot assign to read only property 'prototype'`\n    // so we need to use function implementation here.\n    function FakeDate() {\n      if (arguments.length === 0) {\n        var d = new OriginalDate();\n        d.setTime(FakeDate.now());\n        return d;\n      } else {\n        var args = Array.prototype.slice.call(arguments);\n        return new (OriginalDate.bind.apply(OriginalDate, __spreadArray([void 0], args, false)))();\n      }\n    }\n    FakeDate.now = function () {\n      var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n      if (fakeAsyncTestZoneSpec) {\n        return fakeAsyncTestZoneSpec.getFakeSystemTime();\n      }\n      return OriginalDate.now.apply(this, arguments);\n    };\n    FakeDate.UTC = OriginalDate.UTC;\n    FakeDate.parse = OriginalDate.parse;\n    // keep a reference for zone patched timer function\n    var timers = {\n      setTimeout: global.setTimeout,\n      setInterval: global.setInterval,\n      clearTimeout: global.clearTimeout,\n      clearInterval: global.clearInterval\n    };\n    var Scheduler = /** @class */function () {\n      function Scheduler() {\n        // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n        this._schedulerQueue = [];\n        // Current simulated time in millis.\n        this._currentTickTime = 0;\n        // Current fake system base time in millis.\n        this._currentFakeBaseSystemTime = OriginalDate.now();\n        // track requeuePeriodicTimer\n        this._currentTickRequeuePeriodicEntries = [];\n      }\n      Scheduler.prototype.getCurrentTickTime = function () {\n        return this._currentTickTime;\n      };\n      Scheduler.prototype.getFakeSystemTime = function () {\n        return this._currentFakeBaseSystemTime + this._currentTickTime;\n      };\n      Scheduler.prototype.setFakeBaseSystemTime = function (fakeBaseSystemTime) {\n        this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n      };\n      Scheduler.prototype.getRealSystemTime = function () {\n        return OriginalDate.now();\n      };\n      Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n        options = __assign({\n          args: [],\n          isPeriodic: false,\n          isRequestAnimationFrame: false,\n          id: -1,\n          isRequeuePeriodic: false\n        }, options);\n        var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n        var endTime = this._currentTickTime + delay;\n        // Insert so that scheduler queue remains sorted by end time.\n        var newEntry = {\n          endTime: endTime,\n          id: currentId,\n          func: cb,\n          args: options.args,\n          delay: delay,\n          isPeriodic: options.isPeriodic,\n          isRequestAnimationFrame: options.isRequestAnimationFrame\n        };\n        if (options.isRequeuePeriodic) {\n          this._currentTickRequeuePeriodicEntries.push(newEntry);\n        }\n        var i = 0;\n        for (; i < this._schedulerQueue.length; i++) {\n          var currentEntry = this._schedulerQueue[i];\n          if (newEntry.endTime < currentEntry.endTime) {\n            break;\n          }\n        }\n        this._schedulerQueue.splice(i, 0, newEntry);\n        return currentId;\n      };\n      Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n        for (var i = 0; i < this._schedulerQueue.length; i++) {\n          if (this._schedulerQueue[i].id == id) {\n            this._schedulerQueue.splice(i, 1);\n            break;\n          }\n        }\n      };\n      Scheduler.prototype.removeAll = function () {\n        this._schedulerQueue = [];\n      };\n      Scheduler.prototype.getTimerCount = function () {\n        return this._schedulerQueue.length;\n      };\n      Scheduler.prototype.tickToNext = function (step, doTick, tickOptions) {\n        if (step === void 0) {\n          step = 1;\n        }\n        if (this._schedulerQueue.length < step) {\n          return;\n        }\n        // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n        var startTime = this._currentTickTime;\n        var targetTask = this._schedulerQueue[step - 1];\n        this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n      };\n      Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n        var finalTime = this._currentTickTime + millis;\n        var lastCurrentTime = 0;\n        tickOptions = Object.assign({\n          processNewMacroTasksSynchronously: true\n        }, tickOptions);\n        // we need to copy the schedulerQueue so nested timeout\n        // will not be wrongly called in the current tick\n        // https://github.com/angular/angular/issues/33799\n        var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n        if (schedulerQueue.length === 0 && doTick) {\n          doTick(millis);\n          return;\n        }\n        while (schedulerQueue.length > 0) {\n          // clear requeueEntries before each loop\n          this._currentTickRequeuePeriodicEntries = [];\n          var current = schedulerQueue[0];\n          if (finalTime < current.endTime) {\n            // Done processing the queue since it's sorted by endTime.\n            break;\n          } else {\n            // Time to run scheduled function. Remove it from the head of queue.\n            var current_1 = schedulerQueue.shift();\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              var idx = this._schedulerQueue.indexOf(current_1);\n              if (idx >= 0) {\n                this._schedulerQueue.splice(idx, 1);\n              }\n            }\n            lastCurrentTime = this._currentTickTime;\n            this._currentTickTime = current_1.endTime;\n            if (doTick) {\n              doTick(this._currentTickTime - lastCurrentTime);\n            }\n            var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTickTime] : current_1.args);\n            if (!retval) {\n              // Uncaught exception in the current scheduled function. Stop processing the queue.\n              break;\n            }\n            // check is there any requeue periodic entry is added in\n            // current loop, if there is, we need to add to current loop\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                var i = 0;\n                for (; i < schedulerQueue.length; i++) {\n                  var currentEntry = schedulerQueue[i];\n                  if (newEntry.endTime < currentEntry.endTime) {\n                    break;\n                  }\n                }\n                schedulerQueue.splice(i, 0, newEntry);\n              });\n            }\n          }\n        }\n        lastCurrentTime = this._currentTickTime;\n        this._currentTickTime = finalTime;\n        if (doTick) {\n          doTick(this._currentTickTime - lastCurrentTime);\n        }\n      };\n      Scheduler.prototype.flushOnlyPendingTimers = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        }\n        // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick, {\n          processNewMacroTasksSynchronously: false\n        });\n        return this._currentTickTime - startTime;\n      };\n      Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n        if (limit === void 0) {\n          limit = 20;\n        }\n        if (flushPeriodic === void 0) {\n          flushPeriodic = false;\n        }\n        if (flushPeriodic) {\n          return this.flushPeriodic(doTick);\n        } else {\n          return this.flushNonPeriodic(limit, doTick);\n        }\n      };\n      Scheduler.prototype.flushPeriodic = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        }\n        // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick);\n        return this._currentTickTime - startTime;\n      };\n      Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n        var startTime = this._currentTickTime;\n        var lastCurrentTime = 0;\n        var count = 0;\n        while (this._schedulerQueue.length > 0) {\n          count++;\n          if (count > limit) {\n            throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n          }\n          // flush only non-periodic timers.\n          // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n          if (this._schedulerQueue.filter(function (task) {\n            return !task.isPeriodic && !task.isRequestAnimationFrame;\n          }).length === 0) {\n            break;\n          }\n          var current = this._schedulerQueue.shift();\n          lastCurrentTime = this._currentTickTime;\n          this._currentTickTime = current.endTime;\n          if (doTick) {\n            // Update any secondary schedulers like Jasmine mock Date.\n            doTick(this._currentTickTime - lastCurrentTime);\n          }\n          var retval = current.func.apply(global, current.args);\n          if (!retval) {\n            // Uncaught exception in the current scheduled function. Stop processing the queue.\n            break;\n          }\n        }\n        return this._currentTickTime - startTime;\n      };\n      return Scheduler;\n    }();\n    // Next scheduler id.\n    Scheduler.nextId = 1;\n    var FakeAsyncTestZoneSpec = /** @class */function () {\n      function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n        if (trackPendingRequestAnimationFrame === void 0) {\n          trackPendingRequestAnimationFrame = false;\n        }\n        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n        this.macroTaskOptions = macroTaskOptions;\n        this._scheduler = new Scheduler();\n        this._microtasks = [];\n        this._lastError = null;\n        this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n        this.patchDateLocked = false;\n        this.properties = {\n          'FakeAsyncTestZoneSpec': this\n        };\n        this.name = 'fakeAsyncTestZone for ' + namePrefix;\n        // in case user can't access the construction of FakeAsyncTestSpec\n        // user can also define macroTaskOptions by define a global variable.\n        if (!this.macroTaskOptions) {\n          this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n        }\n      }\n      FakeAsyncTestZoneSpec.assertInZone = function () {\n        if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      };\n      FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n        var _this = this;\n        return function () {\n          var args = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n          fn.apply(global, args);\n          if (_this._lastError === null) {\n            // Success\n            if (completers.onSuccess != null) {\n              completers.onSuccess.apply(global);\n            }\n            // Flush microtasks only on success.\n            _this.flushMicrotasks();\n          } else {\n            // Failure\n            if (completers.onError != null) {\n              completers.onError.apply(global);\n            }\n          }\n          // Return true if there were no errors, false otherwise.\n          return _this._lastError === null;\n        };\n      };\n      FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n        var index = timers.indexOf(id);\n        if (index > -1) {\n          timers.splice(index, 1);\n        }\n      };\n      FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n        var _this = this;\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n        };\n      };\n      FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n        var _this = this;\n        return function () {\n          // Requeue the timer callback if it's not been canceled.\n          if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n            _this._scheduler.scheduleFunction(fn, interval, {\n              args: args,\n              isPeriodic: true,\n              id: id,\n              isRequeuePeriodic: true\n            });\n          }\n        };\n      };\n      FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n        var _this = this;\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n        };\n      };\n      FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n        if (isTimer === void 0) {\n          isTimer = true;\n        }\n        var removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n        // Queue the callback and dequeue the timer on success and error.\n        var cb = this._fnAndFlush(fn, {\n          onSuccess: removeTimerFn,\n          onError: removeTimerFn\n        });\n        var id = this._scheduler.scheduleFunction(cb, delay, {\n          args: args,\n          isRequestAnimationFrame: !isTimer\n        });\n        if (isTimer) {\n          this.pendingTimers.push(id);\n        }\n        return id;\n      };\n      FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n      FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n        var id = Scheduler.nextId;\n        var completers = {\n          onSuccess: null,\n          onError: this._dequeuePeriodicTimer(id)\n        };\n        var cb = this._fnAndFlush(fn, completers);\n        // Use the callback created above to requeue on success.\n        completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n        // Queue the callback and dequeue the periodic timer only on error.\n        this._scheduler.scheduleFunction(cb, interval, {\n          args: args,\n          isPeriodic: true\n        });\n        this.pendingPeriodicTimers.push(id);\n        return id;\n      };\n      FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n      FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n        var error = this._lastError || this._uncaughtPromiseErrors[0];\n        this._uncaughtPromiseErrors.length = 0;\n        this._lastError = null;\n        throw error;\n      };\n      FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {\n        return this._scheduler.getCurrentTickTime();\n      };\n      FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {\n        return this._scheduler.getFakeSystemTime();\n      };\n      FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {\n        this._scheduler.setFakeBaseSystemTime(realTime);\n      };\n      FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {\n        return this._scheduler.getRealSystemTime();\n      };\n      FakeAsyncTestZoneSpec.patchDate = function () {\n        if (!!global[Zone.__symbol__('disableDatePatching')]) {\n          // we don't want to patch global Date\n          // because in some case, global Date\n          // is already being patched, we need to provide\n          // an option to let user still use their\n          // own version of Date.\n          return;\n        }\n        if (global['Date'] === FakeDate) {\n          // already patched\n          return;\n        }\n        global['Date'] = FakeDate;\n        FakeDate.prototype = OriginalDate.prototype;\n        // try check and reset timers\n        // because jasmine.clock().install() may\n        // have replaced the global timer\n        FakeAsyncTestZoneSpec.checkTimerPatch();\n      };\n      FakeAsyncTestZoneSpec.resetDate = function () {\n        if (global['Date'] === FakeDate) {\n          global['Date'] = OriginalDate;\n        }\n      };\n      FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n        if (global.setTimeout !== timers.setTimeout) {\n          global.setTimeout = timers.setTimeout;\n          global.clearTimeout = timers.clearTimeout;\n        }\n        if (global.setInterval !== timers.setInterval) {\n          global.setInterval = timers.setInterval;\n          global.clearInterval = timers.clearInterval;\n        }\n      };\n      FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n        this.patchDateLocked = true;\n        FakeAsyncTestZoneSpec.patchDate();\n      };\n      FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n        this.patchDateLocked = false;\n        FakeAsyncTestZoneSpec.resetDate();\n      };\n      FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {\n        if (steps === void 0) {\n          steps = 1;\n        }\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n        if (steps <= 0) {\n          return;\n        }\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n        this._scheduler.tickToNext(steps, doTick, tickOptions);\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n      FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n        this._scheduler.tick(millis, doTick, tickOptions);\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n      FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n        var _this = this;\n        FakeAsyncTestZoneSpec.assertInZone();\n        var flushErrors = function () {\n          if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n            // If there is an error stop processing the microtask queue and rethrow the error.\n            _this._resetLastErrorAndThrow();\n          }\n        };\n        while (this._microtasks.length > 0) {\n          var microtask = this._microtasks.shift();\n          microtask.func.apply(microtask.target, microtask.args);\n        }\n        flushErrors();\n      };\n      FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n        var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n        return elapsed;\n      };\n      FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n        var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n        return elapsed;\n      };\n      FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this._scheduler.removeAll();\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n      };\n      FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {\n        return this._scheduler.getTimerCount() + this._microtasks.length;\n      };\n      FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        switch (task.type) {\n          case 'microTask':\n            var args = task.data && task.data.args;\n            // should pass additional arguments to callback if have any\n            // currently we know process.nextTick will have such additional\n            // arguments\n            var additionalArgs = void 0;\n            if (args) {\n              var callbackIndex = task.data.cbIdx;\n              if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n              }\n            }\n            this._microtasks.push({\n              func: task.invoke,\n              args: additionalArgs,\n              target: task.data && task.data.target\n            });\n            break;\n          case 'macroTask':\n            switch (task.source) {\n              case 'setTimeout':\n                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n              case 'setImmediate':\n                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                break;\n              case 'setInterval':\n                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n              case 'XMLHttpRequest.send':\n                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n              case 'requestAnimationFrame':\n              case 'webkitRequestAnimationFrame':\n              case 'mozRequestAnimationFrame':\n                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                // (60 frames per second)\n                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                break;\n              default:\n                // user can define which macroTask they want to support by passing\n                // macroTaskOptions\n                var macroTaskOption = this.findMacroTaskOption(task);\n                if (macroTaskOption) {\n                  var args_1 = task.data && task.data['args'];\n                  var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                  var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n                  if (!!macroTaskOption.isPeriodic) {\n                    // periodic macroTask, use setInterval to simulate\n                    task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                    task.data.isPeriodic = true;\n                  } else {\n                    // not periodic, use setTimeout to simulate\n                    task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                  }\n                  break;\n                }\n                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n            }\n            break;\n          case 'eventTask':\n            task = delegate.scheduleTask(target, task);\n            break;\n        }\n        return task;\n      };\n      FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        switch (task.source) {\n          case 'setTimeout':\n          case 'requestAnimationFrame':\n          case 'webkitRequestAnimationFrame':\n          case 'mozRequestAnimationFrame':\n            return this._clearTimeout(task.data['handleId']);\n          case 'setInterval':\n            return this._clearInterval(task.data['handleId']);\n          default:\n            // user can define which macroTask they want to support by passing\n            // macroTaskOptions\n            var macroTaskOption = this.findMacroTaskOption(task);\n            if (macroTaskOption) {\n              var handleId = task.data['handleId'];\n              return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n            }\n            return delegate.cancelTask(target, task);\n        }\n      };\n      FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n        try {\n          FakeAsyncTestZoneSpec.patchDate();\n          return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        } finally {\n          if (!this.patchDateLocked) {\n            FakeAsyncTestZoneSpec.resetDate();\n          }\n        }\n      };\n      FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n        if (!this.macroTaskOptions) {\n          return null;\n        }\n        for (var i = 0; i < this.macroTaskOptions.length; i++) {\n          var macroTaskOption = this.macroTaskOptions[i];\n          if (macroTaskOption.source === task.source) {\n            return macroTaskOption;\n          }\n        }\n        return null;\n      };\n      FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        this._lastError = error;\n        return false; // Don't propagate error to parent zone.\n      };\n\n      return FakeAsyncTestZoneSpec;\n    }();\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n  })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n  Zone.__load_patch('fakeasync', function (global, Zone, api) {\n    var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n    function getProxyZoneSpec() {\n      return Zone && Zone['ProxyZoneSpec'];\n    }\n    var _fakeAsyncTestZoneSpec = null;\n    /**\n     * Clears out the shared fake async zone for a test.\n     * To be called in a global `beforeEach`.\n     *\n     * @experimental\n     */\n    function resetFakeAsyncZone() {\n      if (_fakeAsyncTestZoneSpec) {\n        _fakeAsyncTestZoneSpec.unlockDatePatch();\n      }\n      _fakeAsyncTestZoneSpec = null;\n      // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n      getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n    }\n    /**\n     * Wraps a function to be executed in the fakeAsync zone:\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n     *\n     * If there are any pending timers at the end of the function, an exception will be thrown.\n     *\n     * Can be used to wrap inject() calls.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @param fn\n     * @returns The function wrapped to be executed in the fakeAsync zone\n     *\n     * @experimental\n     */\n    function fakeAsync(fn) {\n      // Not using an arrow function to preserve context passed from call site\n      var fakeAsyncFn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var ProxyZoneSpec = getProxyZoneSpec();\n        if (!ProxyZoneSpec) {\n          throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/proxy');\n        }\n        var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n        if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n        try {\n          // in case jasmine.clock init a fakeAsyncTestZoneSpec\n          if (!_fakeAsyncTestZoneSpec) {\n            if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n              throw new Error('fakeAsync() calls can not be nested');\n            }\n            _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n          }\n          var res = void 0;\n          var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n          proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n          _fakeAsyncTestZoneSpec.lockDatePatch();\n          try {\n            res = fn.apply(this, args);\n            flushMicrotasks();\n          } finally {\n            proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n          }\n          if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n            throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length, \" \") + \"periodic timer(s) still in the queue.\");\n          }\n          if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n            throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingTimers.length, \" timer(s) still in the queue.\"));\n          }\n          return res;\n        } finally {\n          resetFakeAsyncZone();\n        }\n      };\n      fakeAsyncFn.isFakeAsync = true;\n      return fakeAsyncFn;\n    }\n    function _getFakeAsyncZoneSpec() {\n      if (_fakeAsyncTestZoneSpec == null) {\n        _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (_fakeAsyncTestZoneSpec == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      }\n      return _fakeAsyncTestZoneSpec;\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n     *\n     * The microtasks queue is drained at the very start of this function and after any timer callback\n     * has been executed.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @experimental\n     */\n    function tick(millis, ignoreNestedTimeout) {\n      if (millis === void 0) {\n        millis = 0;\n      }\n      if (ignoreNestedTimeout === void 0) {\n        ignoreNestedTimeout = false;\n      }\n      _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\n     * of time that would have been elapsed.\n     *\n     * @param maxTurns\n     * @returns The simulated time elapsed, in millis.\n     *\n     * @experimental\n     */\n    function flush(maxTurns) {\n      return _getFakeAsyncZoneSpec().flush(maxTurns);\n    }\n    /**\n     * Discard all remaining periodic tasks.\n     *\n     * @experimental\n     */\n    function discardPeriodicTasks() {\n      var zoneSpec = _getFakeAsyncZoneSpec();\n      zoneSpec.pendingPeriodicTimers;\n      zoneSpec.pendingPeriodicTimers.length = 0;\n    }\n    /**\n     * Flush any pending microtasks.\n     *\n     * @experimental\n     */\n    function flushMicrotasks() {\n      _getFakeAsyncZoneSpec().flushMicrotasks();\n    }\n    Zone[api.symbol('fakeAsyncTest')] = {\n      resetFakeAsyncZone: resetFakeAsyncZone,\n      flushMicrotasks: flushMicrotasks,\n      discardPeriodicTasks: discardPeriodicTasks,\n      tick: tick,\n      flush: flush,\n      fakeAsync: fakeAsync\n    };\n  }, true);\n  /**\n   * Promise for async/fakeAsync zoneSpec test\n   * can support async operation which not supported by zone.js\n   * such as\n   * it ('test jsonp in AsyncZone', async() => {\n   *   new Promise(res => {\n   *     jsonp(url, (data) => {\n   *       // success callback\n   *       res(data);\n   *     });\n   *   }).then((jsonpResult) => {\n   *     // get jsonp result.\n   *\n   *     // user will expect AsyncZoneSpec wait for\n   *     // then, but because jsonp is not zone aware\n   *     // AsyncZone will finish before then is called.\n   *   });\n   * });\n   */\n  Zone.__load_patch('promisefortest', function (global, Zone, api) {\n    var symbolState = api.symbol('state');\n    var UNRESOLVED = null;\n    var symbolParentUnresolved = api.symbol('parentUnresolved');\n    // patch Promise.prototype.then to keep an internal\n    // number for tracking unresolved chained promise\n    // we will decrease this number when the parent promise\n    // being resolved/rejected and chained promise was\n    // scheduled as a microTask.\n    // so we can know such kind of chained promise still\n    // not resolved in AsyncTestZone\n    Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n      var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n      if (oriThen) {\n        return;\n      }\n      oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n      Promise.prototype.then = function () {\n        var chained = oriThen.apply(this, arguments);\n        if (this[symbolState] === UNRESOLVED) {\n          // parent promise is unresolved.\n          var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n          if (asyncTestZoneSpec) {\n            asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n            chained[symbolParentUnresolved] = true;\n          }\n        }\n        return chained;\n      };\n    };\n    Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n      // restore origin then\n      var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n      if (oriThen) {\n        Promise.prototype.then = oriThen;\n        Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n      }\n    };\n  });\n});","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArray","to","from","pack","l","ar","Array","slice","concat","factory","define","amd","NEWLINE","IGNORE_FRAMES","creationTrace","ERROR_TAG","SEP_TAG","sepTemplate","LongStackTrace","error","getStacktrace","timestamp","Date","getStacktraceWithUncaughtError","Error","getStacktraceWithCaughtError","err","caughtError","stack","getFrames","split","addErrorStack","lines","trace","frame","push","renderLongStackTrace","frames","longTrace","trim","getTime","traceFrames","lastTime","separator","replace","join","stackTracesEnabled","stackTraceLimit","Zone","name","longStackTraceLimit","getLongStackTrace","undefined","__symbol__","onScheduleTask","parentZoneDelegate","currentZone","targetZone","task","currentTask","data","type","scheduleTask","onHandleError","parentTask","longStack","handleError","captureStackTraces","stackTraces","count","computeIgnoreFrames","frames1","frames2","frame1","indexOf","match","frame2","ProxyZoneSpec","defaultSpecDelegate","_delegateSpec","properties","propertyKeys","lastTaskState","isNeedToTriggerHasTask","tasks","setDelegate","get","current","isLoaded","assertPresent","delegateSpec","_this","isNewDelegate","forEach","key","keys","k","macroTask","microTask","getDelegate","resetDelegate","tryTriggerHasTask","onHasTask","removeFromTasks","splice","getAndClearPendingTasksInfo","taskInfo","map","dataInfo","source","pendingTasksInfo","onFork","zoneSpec","fork","onIntercept","delegate","intercept","onInvoke","applyThis","applyArgs","invoke","onInvokeTask","invokeTask","onCancelTask","cancelTask","target","hasTaskState","hasTask","SyncTestZoneSpec","namePrefix","runZone","__load_patch","global","api","__extends","d","b","__","constructor","create","jest","jasmine","ambientZone","symbol","disablePatchingJasmineClock","enableAutoFakeAsyncWhenClockPatched","ignoreUnhandledRejection","globalErrors_1","GlobalErrors","instance","originalInstall","install","isNode","process","on","originalHandlers","listeners","eventListeners","result","removeAllListeners","handler","addEventListener","jasmineEnv","getEnv","methodName","originalJasmineFn","description","specDefinitions","wrapDescribeInZone","timeout","wrapTestInZone","originalClockFn_1","clock","originalTick_1","tick","fakeAsyncZoneSpec","originalMockDate_1","mockDate","dateTime","setFakeBaseSystemTime","originalClockFn","FakeAsyncTestZoneSpec","originalCreateSpyObj_1","createSpyObj","args","propertyNames","spyObj","defineProperty_1","defineProperty","obj","attributes","configurable","enumerable","describeBody","syncZone","run","runInTestZone","testBody","queueRunner","done","isClockInstalled","testProxyZoneSpec","testProxyZone","fakeAsyncModule","fakeAsync","QueueRunner","_super","ZoneQueueRunner","attrs","onComplete","fn","scheduleMicroTask","nativeSetTimeout","nativeClearTimeout","setTimeout","clearTimeout","UserContext","userContext","onException","message","proxyZoneSpec","execute","zone","isChildOfAmbientZone","parent","context","rootZone","proxyZone","wrapDescribeFactoryInZone","originalJestFn","tableArgs","_i","originalDescribeFn","wrapTestFactoryInZone","isTestFunc","wrappedFunc","isFakeAsync","writable","each","describe","only","fdescribe","skip","xdescribe","todo","it","fit","xit","test","patchJestObject","Timer","isModern","isPatchingFakeTimer","isInTestFunc","patchMethod","self","getRealSystemTime","flushMicrotasks","flush","flushOnlyPendingTimers","tickToNext","removeAllTimers","getTimerCount","Mocha","testZone","suiteZone","mochaOriginal","after","afterEach","before","beforeEach","modifyArguments","syncTest","asyncTest","_loop_1","arg","toString","wrapSuiteInZone","suite","specify","xspecify","suiteTeardown","teardown","suiteSetup","setup","originalRunTest","originalRun","Runner","runTest","e","_global","AsyncTestZoneSpec","finishCallback","failCallback","_pendingMicroTasks","_pendingMacroTasks","_alreadyErrored","_isSync","_existingFinishTimer","entryFunction","unresolvedChainedPromiseCount","supportWaitUnresolvedChainedPromise","isUnresolvedChainedPromisePending","_finishCallbackIfDone","patchPromiseForTest","Promise","unPatchPromiseForTest","symbolParentUnresolved","change","window","fail","getZoneWith","previousDelegate","testZoneSpec","runGuarded","OriginalDate","FakeDate","setTime","now","bind","fakeAsyncTestZoneSpec","getFakeSystemTime","UTC","parse","timers","setInterval","clearInterval","Scheduler","_schedulerQueue","_currentTickTime","_currentFakeBaseSystemTime","_currentTickRequeuePeriodicEntries","getCurrentTickTime","fakeBaseSystemTime","scheduleFunction","cb","delay","options","isPeriodic","isRequestAnimationFrame","id","isRequeuePeriodic","currentId","nextId","endTime","newEntry","func","currentEntry","removeScheduledFunctionWithId","removeAll","step","doTick","tickOptions","startTime","targetTask","millis","finalTime","lastCurrentTime","processNewMacroTasksSynchronously","schedulerQueue","current_1","shift","idx","retval","lastTask","limit","flushPeriodic","flushNonPeriodic","filter","trackPendingRequestAnimationFrame","macroTaskOptions","_scheduler","_microtasks","_lastError","_uncaughtPromiseErrors","pendingPeriodicTimers","pendingTimers","patchDateLocked","assertInZone","_fnAndFlush","completers","onSuccess","onError","_removeTimer","index","_dequeueTimer","_requeuePeriodicTimer","interval","_dequeuePeriodicTimer","_setTimeout","isTimer","removeTimerFn","_clearTimeout","_setInterval","_clearInterval","_resetLastErrorAndThrow","realTime","patchDate","checkTimerPatch","resetDate","lockDatePatch","unlockDatePatch","steps","flushErrors","microtask","elapsed","additionalArgs","callbackIndex","cbIdx","macroTaskOption","findMacroTaskOption","args_1","callbackArgs","handleId","callback","getProxyZoneSpec","_fakeAsyncTestZoneSpec","resetFakeAsyncZone","fakeAsyncFn","res","lastProxyZoneSpec","_getFakeAsyncZoneSpec","ignoreNestedTimeout","maxTurns","discardPeriodicTasks","symbolState","UNRESOLVED","oriThen","then","chained","asyncTestZoneSpec","unpatchPromiseForTest"],"sources":["/Users/welingtonmarquezini/Projects/Investment/src/Investment.View/ClientApp/node_modules/zone.js/dist/zone-testing.js"],"sourcesContent":["'use strict';\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * @license Angular v<unknown>\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n        factory();\n})((function () {\n    'use strict';\n    /**\n     * @fileoverview\n     * @suppress {globalThis}\n     */\n    var NEWLINE = '\\n';\n    var IGNORE_FRAMES = {};\n    var creationTrace = '__creationTrace__';\n    var ERROR_TAG = 'STACKTRACE TRACKING';\n    var SEP_TAG = '__SEP_TAG__';\n    var sepTemplate = SEP_TAG + '@[native]';\n    var LongStackTrace = /** @class */ (function () {\n        function LongStackTrace() {\n            this.error = getStacktrace();\n            this.timestamp = new Date();\n        }\n        return LongStackTrace;\n    }());\n    function getStacktraceWithUncaughtError() {\n        return new Error(ERROR_TAG);\n    }\n    function getStacktraceWithCaughtError() {\n        try {\n            throw getStacktraceWithUncaughtError();\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    // Some implementations of exception handling don't create a stack trace if the exception\n    // isn't thrown, however it's faster not to actually throw the exception.\n    var error = getStacktraceWithUncaughtError();\n    var caughtError = getStacktraceWithCaughtError();\n    var getStacktrace = error.stack ?\n        getStacktraceWithUncaughtError :\n        (caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError);\n    function getFrames(error) {\n        return error.stack ? error.stack.split(NEWLINE) : [];\n    }\n    function addErrorStack(lines, error) {\n        var trace = getFrames(error);\n        for (var i = 0; i < trace.length; i++) {\n            var frame = trace[i];\n            // Filter out the Frames which are part of stack capturing.\n            if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n                lines.push(trace[i]);\n            }\n        }\n    }\n    function renderLongStackTrace(frames, stack) {\n        var longTrace = [stack ? stack.trim() : ''];\n        if (frames) {\n            var timestamp = new Date().getTime();\n            for (var i = 0; i < frames.length; i++) {\n                var traceFrames = frames[i];\n                var lastTime = traceFrames.timestamp;\n                var separator = \"____________________Elapsed \".concat(timestamp - lastTime.getTime(), \" ms; At: \").concat(lastTime);\n                separator = separator.replace(/[^\\w\\d]/g, '_');\n                longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n                addErrorStack(longTrace, traceFrames.error);\n                timestamp = lastTime.getTime();\n            }\n        }\n        return longTrace.join(NEWLINE);\n    }\n    // if Error.stackTraceLimit is 0, means stack trace\n    // is disabled, so we don't need to generate long stack trace\n    // this will improve performance in some test(some test will\n    // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n    function stackTracesEnabled() {\n        // Cast through any since this property only exists on Error in the nodejs\n        // typings.\n        return Error.stackTraceLimit > 0;\n    }\n    Zone['longStackTraceZoneSpec'] = {\n        name: 'long-stack-trace',\n        longStackTraceLimit: 10,\n        // add a getLongStackTrace method in spec to\n        // handle handled reject promise error.\n        getLongStackTrace: function (error) {\n            if (!error) {\n                return undefined;\n            }\n            var trace = error[Zone.__symbol__('currentTaskTrace')];\n            if (!trace) {\n                return error.stack;\n            }\n            return renderLongStackTrace(trace, error.stack);\n        },\n        onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (stackTracesEnabled()) {\n                var currentTask = Zone.currentTask;\n                var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n                trace = [new LongStackTrace()].concat(trace);\n                if (trace.length > this.longStackTraceLimit) {\n                    trace.length = this.longStackTraceLimit;\n                }\n                if (!task.data)\n                    task.data = {};\n                if (task.type === 'eventTask') {\n                    // Fix issue https://github.com/angular/zone.js/issues/1195,\n                    // For event task of browser, by default, all task will share a\n                    // singleton instance of data object, we should create a new one here\n                    // The cast to `any` is required to workaround a closure bug which wrongly applies\n                    // URL sanitization rules to .data access.\n                    task.data = __assign({}, task.data);\n                }\n                task.data[creationTrace] = trace;\n            }\n            return parentZoneDelegate.scheduleTask(targetZone, task);\n        },\n        onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (stackTracesEnabled()) {\n                var parentTask = Zone.currentTask || error.task;\n                if (error instanceof Error && parentTask) {\n                    var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n                    try {\n                        error.stack = error.longStack = longStack;\n                    }\n                    catch (err) {\n                    }\n                }\n            }\n            return parentZoneDelegate.handleError(targetZone, error);\n        }\n    };\n    function captureStackTraces(stackTraces, count) {\n        if (count > 0) {\n            stackTraces.push(getFrames((new LongStackTrace()).error));\n            captureStackTraces(stackTraces, count - 1);\n        }\n    }\n    function computeIgnoreFrames() {\n        if (!stackTracesEnabled()) {\n            return;\n        }\n        var frames = [];\n        captureStackTraces(frames, 2);\n        var frames1 = frames[0];\n        var frames2 = frames[1];\n        for (var i = 0; i < frames1.length; i++) {\n            var frame1 = frames1[i];\n            if (frame1.indexOf(ERROR_TAG) == -1) {\n                var match = frame1.match(/^\\s*at\\s+/);\n                if (match) {\n                    sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n                    break;\n                }\n            }\n        }\n        for (var i = 0; i < frames1.length; i++) {\n            var frame1 = frames1[i];\n            var frame2 = frames2[i];\n            if (frame1 === frame2) {\n                IGNORE_FRAMES[frame1] = true;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    computeIgnoreFrames();\n    var ProxyZoneSpec = /** @class */ (function () {\n        function ProxyZoneSpec(defaultSpecDelegate) {\n            if (defaultSpecDelegate === void 0) { defaultSpecDelegate = null; }\n            this.defaultSpecDelegate = defaultSpecDelegate;\n            this.name = 'ProxyZone';\n            this._delegateSpec = null;\n            this.properties = { 'ProxyZoneSpec': this };\n            this.propertyKeys = null;\n            this.lastTaskState = null;\n            this.isNeedToTriggerHasTask = false;\n            this.tasks = [];\n            this.setDelegate(defaultSpecDelegate);\n        }\n        ProxyZoneSpec.get = function () {\n            return Zone.current.get('ProxyZoneSpec');\n        };\n        ProxyZoneSpec.isLoaded = function () {\n            return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n        };\n        ProxyZoneSpec.assertPresent = function () {\n            if (!ProxyZoneSpec.isLoaded()) {\n                throw new Error(\"Expected to be running in 'ProxyZone', but it was not found.\");\n            }\n            return ProxyZoneSpec.get();\n        };\n        ProxyZoneSpec.prototype.setDelegate = function (delegateSpec) {\n            var _this = this;\n            var isNewDelegate = this._delegateSpec !== delegateSpec;\n            this._delegateSpec = delegateSpec;\n            this.propertyKeys && this.propertyKeys.forEach(function (key) { return delete _this.properties[key]; });\n            this.propertyKeys = null;\n            if (delegateSpec && delegateSpec.properties) {\n                this.propertyKeys = Object.keys(delegateSpec.properties);\n                this.propertyKeys.forEach(function (k) { return _this.properties[k] = delegateSpec.properties[k]; });\n            }\n            // if a new delegateSpec was set, check if we need to trigger hasTask\n            if (isNewDelegate && this.lastTaskState &&\n                (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n                this.isNeedToTriggerHasTask = true;\n            }\n        };\n        ProxyZoneSpec.prototype.getDelegate = function () {\n            return this._delegateSpec;\n        };\n        ProxyZoneSpec.prototype.resetDelegate = function () {\n            this.getDelegate();\n            this.setDelegate(this.defaultSpecDelegate);\n        };\n        ProxyZoneSpec.prototype.tryTriggerHasTask = function (parentZoneDelegate, currentZone, targetZone) {\n            if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n                // last delegateSpec has microTask or macroTask\n                // should call onHasTask in current delegateSpec\n                this.isNeedToTriggerHasTask = false;\n                this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n            }\n        };\n        ProxyZoneSpec.prototype.removeFromTasks = function (task) {\n            if (!this.tasks) {\n                return;\n            }\n            for (var i = 0; i < this.tasks.length; i++) {\n                if (this.tasks[i] === task) {\n                    this.tasks.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        ProxyZoneSpec.prototype.getAndClearPendingTasksInfo = function () {\n            if (this.tasks.length === 0) {\n                return '';\n            }\n            var taskInfo = this.tasks.map(function (task) {\n                var dataInfo = task.data &&\n                    Object.keys(task.data)\n                        .map(function (key) {\n                        return key + ':' + task.data[key];\n                    })\n                        .join(',');\n                return \"type: \".concat(task.type, \", source: \").concat(task.source, \", args: {\").concat(dataInfo, \"}\");\n            });\n            var pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']';\n            // clear tasks\n            this.tasks = [];\n            return pendingTasksInfo;\n        };\n        ProxyZoneSpec.prototype.onFork = function (parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n            if (this._delegateSpec && this._delegateSpec.onFork) {\n                return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n            }\n            else {\n                return parentZoneDelegate.fork(targetZone, zoneSpec);\n            }\n        };\n        ProxyZoneSpec.prototype.onIntercept = function (parentZoneDelegate, currentZone, targetZone, delegate, source) {\n            if (this._delegateSpec && this._delegateSpec.onIntercept) {\n                return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n            }\n            else {\n                return parentZoneDelegate.intercept(targetZone, delegate, source);\n            }\n        };\n        ProxyZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onInvoke) {\n                return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n            }\n            else {\n                return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n            }\n        };\n        ProxyZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (this._delegateSpec && this._delegateSpec.onHandleError) {\n                return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n            }\n            else {\n                return parentZoneDelegate.handleError(targetZone, error);\n            }\n        };\n        ProxyZoneSpec.prototype.onScheduleTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (task.type !== 'eventTask') {\n                this.tasks.push(task);\n            }\n            if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n                return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n            }\n            else {\n                return parentZoneDelegate.scheduleTask(targetZone, task);\n            }\n        };\n        ProxyZoneSpec.prototype.onInvokeTask = function (parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n            if (task.type !== 'eventTask') {\n                this.removeFromTasks(task);\n            }\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n                return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n            }\n            else {\n                return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n            }\n        };\n        ProxyZoneSpec.prototype.onCancelTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (task.type !== 'eventTask') {\n                this.removeFromTasks(task);\n            }\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n                return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n            }\n            else {\n                return parentZoneDelegate.cancelTask(targetZone, task);\n            }\n        };\n        ProxyZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n            this.lastTaskState = hasTaskState;\n            if (this._delegateSpec && this._delegateSpec.onHasTask) {\n                this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n            }\n            else {\n                delegate.hasTask(target, hasTaskState);\n            }\n        };\n        return ProxyZoneSpec;\n    }());\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n    var SyncTestZoneSpec = /** @class */ (function () {\n        function SyncTestZoneSpec(namePrefix) {\n            this.runZone = Zone.current;\n            this.name = 'syncTestZone for ' + namePrefix;\n        }\n        SyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n            switch (task.type) {\n                case 'microTask':\n                case 'macroTask':\n                    throw new Error(\"Cannot call \".concat(task.source, \" from within a sync test (\").concat(this.name, \").\"));\n                case 'eventTask':\n                    task = delegate.scheduleTask(target, task);\n                    break;\n            }\n            return task;\n        };\n        return SyncTestZoneSpec;\n    }());\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n    /// <reference types=\"jasmine\"/>\n    Zone.__load_patch('jasmine', function (global, Zone, api) {\n        var __extends = function (d, b) {\n            for (var p in b)\n                if (b.hasOwnProperty(p))\n                    d[p] = b[p];\n            function __() {\n                this.constructor = d;\n            }\n            d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n        };\n        // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n        // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n        if (!Zone)\n            throw new Error('Missing: zone.js');\n        if (typeof jest !== 'undefined') {\n            // return if jasmine is a light implementation inside jest\n            // in this case, we are running inside jest not jasmine\n            return;\n        }\n        if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n            return;\n        }\n        jasmine['__zone_patch__'] = true;\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        if (!SyncTestZoneSpec)\n            throw new Error('Missing: SyncTestZoneSpec');\n        if (!ProxyZoneSpec)\n            throw new Error('Missing: ProxyZoneSpec');\n        var ambientZone = Zone.current;\n        var symbol = Zone.__symbol__;\n        // whether patch jasmine clock when in fakeAsync\n        var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n        // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n        // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n        // automatically disable the auto jump into fakeAsync feature\n        var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock &&\n            ((global[symbol('fakeAsyncPatchLock')] === true) ||\n                (global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true));\n        var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n        if (!ignoreUnhandledRejection) {\n            var globalErrors_1 = jasmine.GlobalErrors;\n            if (globalErrors_1 && !jasmine[symbol('GlobalErrors')]) {\n                jasmine[symbol('GlobalErrors')] = globalErrors_1;\n                jasmine.GlobalErrors = function () {\n                    var instance = new globalErrors_1();\n                    var originalInstall = instance.install;\n                    if (originalInstall && !instance[symbol('install')]) {\n                        instance[symbol('install')] = originalInstall;\n                        instance.install = function () {\n                            var isNode = typeof process !== 'undefined' && !!process.on;\n                            // Note: Jasmine checks internally if `process` and `process.on` is defined. Otherwise,\n                            // it installs the browser rejection handler through the `global.addEventListener`.\n                            // This code may be run in the browser environment where `process` is not defined, and\n                            // this will lead to a runtime exception since Webpack 5 removed automatic Node.js\n                            // polyfills. Note, that events are named differently, it's `unhandledRejection` in\n                            // Node.js and `unhandledrejection` in the browser.\n                            var originalHandlers = isNode ? process.listeners('unhandledRejection') :\n                                global.eventListeners('unhandledrejection');\n                            var result = originalInstall.apply(this, arguments);\n                            isNode ? process.removeAllListeners('unhandledRejection') :\n                                global.removeAllListeners('unhandledrejection');\n                            if (originalHandlers) {\n                                originalHandlers.forEach(function (handler) {\n                                    if (isNode) {\n                                        process.on('unhandledRejection', handler);\n                                    }\n                                    else {\n                                        global.addEventListener('unhandledrejection', handler);\n                                    }\n                                });\n                            }\n                            return result;\n                        };\n                    }\n                    return instance;\n                };\n            }\n        }\n        // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n        var jasmineEnv = jasmine.getEnv();\n        ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[methodName] = function (description, specDefinitions) {\n                return originalJasmineFn.call(this, description, wrapDescribeInZone(description, specDefinitions));\n            };\n        });\n        ['it', 'xit', 'fit'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n                arguments[1] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (specDefinitions, timeout) {\n                arguments[0] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        if (!disablePatchingJasmineClock) {\n            // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n            // they can work properly in FakeAsyncTest\n            var originalClockFn_1 = (jasmine[symbol('clock')] = jasmine['clock']);\n            jasmine['clock'] = function () {\n                var clock = originalClockFn_1.apply(this, arguments);\n                if (!clock[symbol('patched')]) {\n                    clock[symbol('patched')] = symbol('patched');\n                    var originalTick_1 = (clock[symbol('tick')] = clock.tick);\n                    clock.tick = function () {\n                        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n                        }\n                        return originalTick_1.apply(this, arguments);\n                    };\n                    var originalMockDate_1 = (clock[symbol('mockDate')] = clock.mockDate);\n                    clock.mockDate = function () {\n                        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n                            return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] :\n                                arguments);\n                        }\n                        return originalMockDate_1.apply(this, arguments);\n                    };\n                    // for auto go into fakeAsync feature, we need the flag to enable it\n                    if (enableAutoFakeAsyncWhenClockPatched) {\n                        ['install', 'uninstall'].forEach(function (methodName) {\n                            var originalClockFn = (clock[symbol(methodName)] = clock[methodName]);\n                            clock[methodName] = function () {\n                                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n                                if (FakeAsyncTestZoneSpec) {\n                                    jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                                    return;\n                                }\n                                return originalClockFn.apply(this, arguments);\n                            };\n                        });\n                    }\n                }\n                return clock;\n            };\n        }\n        // monkey patch createSpyObj to make properties enumerable to true\n        if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n            var originalCreateSpyObj_1 = jasmine.createSpyObj;\n            jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj_1;\n            jasmine.createSpyObj = function () {\n                var args = Array.prototype.slice.call(arguments);\n                var propertyNames = args.length >= 3 ? args[2] : null;\n                var spyObj;\n                if (propertyNames) {\n                    var defineProperty_1 = Object.defineProperty;\n                    Object.defineProperty = function (obj, p, attributes) {\n                        return defineProperty_1.call(this, obj, p, __assign(__assign({}, attributes), { configurable: true, enumerable: true }));\n                    };\n                    try {\n                        spyObj = originalCreateSpyObj_1.apply(this, args);\n                    }\n                    finally {\n                        Object.defineProperty = defineProperty_1;\n                    }\n                }\n                else {\n                    spyObj = originalCreateSpyObj_1.apply(this, args);\n                }\n                return spyObj;\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(description, describeBody) {\n            return function () {\n                // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n                // error if any asynchronous operations are attempted inside of a `describe`.\n                var syncZone = ambientZone.fork(new SyncTestZoneSpec(\"jasmine.describe#\".concat(description)));\n                return syncZone.run(describeBody, this, arguments);\n            };\n        }\n        function runInTestZone(testBody, applyThis, queueRunner, done) {\n            var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n            queueRunner.testProxyZoneSpec;\n            var testProxyZone = queueRunner.testProxyZone;\n            if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n                // auto run a fakeAsync\n                var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                    testBody = fakeAsyncModule.fakeAsync(testBody);\n                }\n            }\n            if (done) {\n                return testProxyZone.run(testBody, applyThis, [done]);\n            }\n            else {\n                return testProxyZone.run(testBody, applyThis);\n            }\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n         */\n        function wrapTestInZone(testBody) {\n            // The `done` callback is only passed through if the function expects at least one argument.\n            // Note we have to make a function with correct number of arguments, otherwise jasmine will\n            // think that all functions are sync or async.\n            return (testBody && (testBody.length ? function (done) {\n                return runInTestZone(testBody, this, this.queueRunner, done);\n            } : function () {\n                return runInTestZone(testBody, this, this.queueRunner);\n            }));\n        }\n        var QueueRunner = jasmine.QueueRunner;\n        jasmine.QueueRunner = (function (_super) {\n            __extends(ZoneQueueRunner, _super);\n            function ZoneQueueRunner(attrs) {\n                var _this = this;\n                if (attrs.onComplete) {\n                    attrs.onComplete = (function (fn) { return function () {\n                        // All functions are done, clear the test zone.\n                        _this.testProxyZone = null;\n                        _this.testProxyZoneSpec = null;\n                        ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n                    }; })(attrs.onComplete);\n                }\n                var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n                var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n                if (nativeSetTimeout) {\n                    // should run setTimeout inside jasmine outside of zone\n                    attrs.timeout = {\n                        setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n                        clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n                    };\n                }\n                // create a userContext to hold the queueRunner itself\n                // so we can access the testProxy in it/xit/beforeEach ...\n                if (jasmine.UserContext) {\n                    if (!attrs.userContext) {\n                        attrs.userContext = new jasmine.UserContext();\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                else {\n                    if (!attrs.userContext) {\n                        attrs.userContext = {};\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                // patch attrs.onException\n                var onException = attrs.onException;\n                attrs.onException = function (error) {\n                    if (error &&\n                        error.message ===\n                            'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n                        // jasmine timeout, we can make the error message more\n                        // reasonable to tell what tasks are pending\n                        var proxyZoneSpec = this && this.testProxyZoneSpec;\n                        if (proxyZoneSpec) {\n                            var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n                            try {\n                                // try catch here in case error.message is not writable\n                                error.message += pendingTasksInfo;\n                            }\n                            catch (err) {\n                            }\n                        }\n                    }\n                    if (onException) {\n                        onException.call(this, error);\n                    }\n                };\n                _super.call(this, attrs);\n            }\n            ZoneQueueRunner.prototype.execute = function () {\n                var _this = this;\n                var zone = Zone.current;\n                var isChildOfAmbientZone = false;\n                while (zone) {\n                    if (zone === ambientZone) {\n                        isChildOfAmbientZone = true;\n                        break;\n                    }\n                    zone = zone.parent;\n                }\n                if (!isChildOfAmbientZone)\n                    throw new Error('Unexpected Zone: ' + Zone.current.name);\n                // This is the zone which will be used for running individual tests.\n                // It will be a proxy zone, so that the tests function can retroactively install\n                // different zones.\n                // Example:\n                //   - In beforeEach() do childZone = Zone.current.fork(...);\n                //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n                //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n                //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n                //     fakeAsync behavior to the childZone.\n                this.testProxyZoneSpec = new ProxyZoneSpec();\n                this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n                if (!Zone.currentTask) {\n                    // if we are not running in a task then if someone would register a\n                    // element.addEventListener and then calling element.click() the\n                    // addEventListener callback would think that it is the top most task and would\n                    // drain the microtask queue on element.click() which would be incorrect.\n                    // For this reason we always force a task when running jasmine tests.\n                    Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () { return QueueRunner.prototype.execute.call(_this); });\n                }\n                else {\n                    _super.prototype.execute.call(this);\n                }\n            };\n            return ZoneQueueRunner;\n        })(QueueRunner);\n    });\n    Zone.__load_patch('jest', function (context, Zone, api) {\n        if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n            return;\n        }\n        jest['__zone_patch__'] = true;\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        var rootZone = Zone.current;\n        var syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n        var proxyZoneSpec = new ProxyZoneSpec();\n        var proxyZone = rootZone.fork(proxyZoneSpec);\n        function wrapDescribeFactoryInZone(originalJestFn) {\n            return function () {\n                var tableArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tableArgs[_i] = arguments[_i];\n                }\n                var originalDescribeFn = originalJestFn.apply(this, tableArgs);\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    args[1] = wrapDescribeInZone(args[1]);\n                    return originalDescribeFn.apply(this, args);\n                };\n            };\n        }\n        function wrapTestFactoryInZone(originalJestFn) {\n            return function () {\n                var tableArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tableArgs[_i] = arguments[_i];\n                }\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    args[1] = wrapTestInZone(args[1]);\n                    return originalJestFn.apply(this, tableArgs).apply(this, args);\n                };\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(describeBody) {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return syncZone.run(describeBody, this, args);\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in the `proxyZone`.\n         */\n        function wrapTestInZone(testBody, isTestFunc) {\n            if (isTestFunc === void 0) { isTestFunc = false; }\n            if (typeof testBody !== 'function') {\n                return testBody;\n            }\n            var wrappedFunc = function () {\n                if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody &&\n                    !testBody.isFakeAsync) {\n                    // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n                    var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                    if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                        testBody = fakeAsyncModule.fakeAsync(testBody);\n                    }\n                }\n                proxyZoneSpec.isTestFunc = isTestFunc;\n                return proxyZone.run(testBody, null, arguments);\n            };\n            // Update the length of wrappedFunc to be the same as the length of the testBody\n            // So jest core can handle whether the test function has `done()` or not correctly\n            Object.defineProperty(wrappedFunc, 'length', { configurable: true, writable: true, enumerable: false });\n            wrappedFunc.length = testBody.length;\n            return wrappedFunc;\n        }\n        ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[1] = wrapDescribeInZone(args[1]);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n        });\n        context.describe.only = context.fdescribe;\n        context.describe.skip = context.xdescribe;\n        ['it', 'xit', 'fit', 'test', 'xtest'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[1] = wrapTestInZone(args[1], true);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n            context[methodName].todo = originalJestFn.todo;\n        });\n        context.it.only = context.fit;\n        context.it.skip = context.xit;\n        context.test.only = context.fit;\n        context.test.skip = context.xit;\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[0] = wrapTestInZone(args[0]);\n                return originalJestFn.apply(this, args);\n            };\n        });\n        Zone.patchJestObject = function patchJestObject(Timer, isModern) {\n            if (isModern === void 0) { isModern = false; }\n            // check whether currently the test is inside fakeAsync()\n            function isPatchingFakeTimer() {\n                var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                return !!fakeAsyncZoneSpec;\n            }\n            // check whether the current function is inside `test/it` or other methods\n            // such as `describe/beforeEach`\n            function isInTestFunc() {\n                var proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n                return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n            }\n            if (Timer[api.symbol('fakeTimers')]) {\n                return;\n            }\n            Timer[api.symbol('fakeTimers')] = true;\n            // patch jest fakeTimer internal method to make sure no console.warn print out\n            api.patchMethod(Timer, '_checkFakeTimers', function (delegate) {\n                return function (self, args) {\n                    if (isPatchingFakeTimer()) {\n                        return true;\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n            api.patchMethod(Timer, 'useFakeTimers', function (delegate) {\n                return function (self, args) {\n                    Zone[api.symbol('useFakeTimersCalled')] = true;\n                    if (isModern || isInTestFunc()) {\n                        return delegate.apply(self, args);\n                    }\n                    return self;\n                };\n            });\n            // patch useRealTimers(), unset useFakeTimers flag\n            api.patchMethod(Timer, 'useRealTimers', function (delegate) {\n                return function (self, args) {\n                    Zone[api.symbol('useFakeTimersCalled')] = false;\n                    if (isModern || isInTestFunc()) {\n                        return delegate.apply(self, args);\n                    }\n                    return self;\n                };\n            });\n            // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n            api.patchMethod(Timer, 'setSystemTime', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                        fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n            api.patchMethod(Timer, 'getRealSystemTime', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                        return fakeAsyncZoneSpec.getRealSystemTime();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runAllTicks(), run all microTasks inside fakeAsync\n            api.patchMethod(Timer, 'runAllTicks', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flushMicrotasks();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runAllTimers(), run all macroTasks inside fakeAsync\n            api.patchMethod(Timer, 'runAllTimers', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flush(100, true);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n            api.patchMethod(Timer, 'advanceTimersByTime', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.tick(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n            api.patchMethod(Timer, 'runOnlyPendingTimers', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flushOnlyPendingTimers();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n            api.patchMethod(Timer, 'advanceTimersToNextTimer', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.tickToNext(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n            api.patchMethod(Timer, 'clearAllTimers', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.removeAllTimers();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n            api.patchMethod(Timer, 'getTimerCount', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        return fakeAsyncZoneSpec.getTimerCount();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n        };\n    });\n    Zone.__load_patch('mocha', function (global, Zone) {\n        var Mocha = global.Mocha;\n        if (typeof Mocha === 'undefined') {\n            // return if Mocha is not available, because now zone-testing\n            // will load mocha patch with jasmine/jest patch\n            return;\n        }\n        if (typeof Zone === 'undefined') {\n            throw new Error('Missing Zone.js');\n        }\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        if (Mocha['__zone_patch__']) {\n            throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n        }\n        Mocha['__zone_patch__'] = true;\n        var rootZone = Zone.current;\n        var syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n        var testZone = null;\n        var suiteZone = rootZone.fork(new ProxyZoneSpec());\n        var mochaOriginal = {\n            after: global.after,\n            afterEach: global.afterEach,\n            before: global.before,\n            beforeEach: global.beforeEach,\n            describe: global.describe,\n            it: global.it\n        };\n        function modifyArguments(args, syncTest, asyncTest) {\n            var _loop_1 = function (i) {\n                var arg = args[i];\n                if (typeof arg === 'function') {\n                    // The `done` callback is only passed through if the function expects at\n                    // least one argument.\n                    // Note we have to make a function with correct number of arguments,\n                    // otherwise mocha will\n                    // think that all functions are sync or async.\n                    args[i] = (arg.length === 0) ? syncTest(arg) : asyncTest(arg);\n                    // Mocha uses toString to view the test body in the result list, make sure we return the\n                    // correct function body\n                    args[i].toString = function () {\n                        return arg.toString();\n                    };\n                }\n            };\n            for (var i = 0; i < args.length; i++) {\n                _loop_1(i);\n            }\n            return args;\n        }\n        function wrapDescribeInZone(args) {\n            var syncTest = function (fn) {\n                return function () {\n                    return syncZone.run(fn, this, arguments);\n                };\n            };\n            return modifyArguments(args, syncTest);\n        }\n        function wrapTestInZone(args) {\n            var asyncTest = function (fn) {\n                return function (done) {\n                    return testZone.run(fn, this, [done]);\n                };\n            };\n            var syncTest = function (fn) {\n                return function () {\n                    return testZone.run(fn, this);\n                };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        function wrapSuiteInZone(args) {\n            var asyncTest = function (fn) {\n                return function (done) {\n                    return suiteZone.run(fn, this, [done]);\n                };\n            };\n            var syncTest = function (fn) {\n                return function () {\n                    return suiteZone.run(fn, this);\n                };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        global.describe = global.suite = function () {\n            return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.xdescribe = global.suite.skip = function () {\n            return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.describe.only = global.suite.only = function () {\n            return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.it = global.specify = global.test = function () {\n            return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n        };\n        global.xit = global.xspecify = function () {\n            return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n        };\n        global.it.only = global.test.only = function () {\n            return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n        };\n        global.after = global.suiteTeardown = function () {\n            return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.afterEach = global.teardown = function () {\n            return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n        };\n        global.before = global.suiteSetup = function () {\n            return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.beforeEach = global.setup = function () {\n            return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n        };\n        (function (originalRunTest, originalRun) {\n            Mocha.Runner.prototype.runTest = function (fn) {\n                var _this = this;\n                Zone.current.scheduleMicroTask('mocha.forceTask', function () {\n                    originalRunTest.call(_this, fn);\n                });\n            };\n            Mocha.Runner.prototype.run = function (fn) {\n                this.on('test', function (e) {\n                    testZone = rootZone.fork(new ProxyZoneSpec());\n                });\n                this.on('fail', function (test, err) {\n                    var proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n                    if (proxyZoneSpec && err) {\n                        try {\n                            // try catch here in case err.message is not writable\n                            err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n                        }\n                        catch (error) {\n                        }\n                    }\n                });\n                return originalRun.call(this, fn);\n            };\n        })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n    });\n    (function (_global) {\n        var AsyncTestZoneSpec = /** @class */ (function () {\n            function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n                this.finishCallback = finishCallback;\n                this.failCallback = failCallback;\n                this._pendingMicroTasks = false;\n                this._pendingMacroTasks = false;\n                this._alreadyErrored = false;\n                this._isSync = false;\n                this._existingFinishTimer = null;\n                this.entryFunction = null;\n                this.runZone = Zone.current;\n                this.unresolvedChainedPromiseCount = 0;\n                this.supportWaitUnresolvedChainedPromise = false;\n                this.name = 'asyncTestZone for ' + namePrefix;\n                this.properties = { 'AsyncTestZoneSpec': this };\n                this.supportWaitUnresolvedChainedPromise =\n                    _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n            }\n            AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {\n                return this.unresolvedChainedPromiseCount > 0;\n            };\n            AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n                var _this = this;\n                // NOTE: Technically the `onHasTask` could fire together with the initial synchronous\n                // completion in `onInvoke`. `onHasTask` might call this method when it captured e.g.\n                // microtasks in the proxy zone that now complete as part of this async zone run.\n                // Consider the following scenario:\n                //    1. A test `beforeEach` schedules a microtask in the ProxyZone.\n                //    2. An actual empty `it` spec executes in the AsyncTestZone` (using e.g. `waitForAsync`).\n                //    3. The `onInvoke` invokes `_finishCallbackIfDone` because the spec runs synchronously.\n                //    4. We wait the scheduled timeout (see below) to account for unhandled promises.\n                //    5. The microtask from (1) finishes and `onHasTask` is invoked.\n                //    --> We register a second `_finishCallbackIfDone` even though we have scheduled a timeout.\n                // If the finish timeout from below is already scheduled, terminate the existing scheduled\n                // finish invocation, avoiding calling `jasmine` `done` multiple times. *Note* that we would\n                // want to schedule a new finish callback in case the task state changes again.\n                if (this._existingFinishTimer !== null) {\n                    clearTimeout(this._existingFinishTimer);\n                    this._existingFinishTimer = null;\n                }\n                if (!(this._pendingMicroTasks || this._pendingMacroTasks ||\n                    (this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending()))) {\n                    // We wait until the next tick because we would like to catch unhandled promises which could\n                    // cause test logic to be executed. In such cases we cannot finish with tasks pending then.\n                    this.runZone.run(function () {\n                        _this._existingFinishTimer = setTimeout(function () {\n                            if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                                _this.finishCallback();\n                            }\n                        }, 0);\n                    });\n                }\n            };\n            AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n                if (patchPromiseForTest) {\n                    patchPromiseForTest();\n                }\n            };\n            AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n                if (unPatchPromiseForTest) {\n                    unPatchPromiseForTest();\n                }\n            };\n            AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n                    // check whether the promise is a chained promise\n                    if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n                        // chained promise is being scheduled\n                        this.unresolvedChainedPromiseCount--;\n                    }\n                }\n                return delegate.scheduleTask(target, task);\n            };\n            AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\n            };\n            AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.cancelTask(target, task);\n            };\n            // Note - we need to use onInvoke at the moment to call finish when a test is\n            // fully synchronous. TODO(juliemr): remove this when the logic for\n            // onHasTask changes and it calls whenever the task queues are dirty.\n            // updated by(JiaLiPassion), only call finish callback when no task\n            // was scheduled/invoked/canceled.\n            AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n                if (!this.entryFunction) {\n                    this.entryFunction = delegate;\n                }\n                try {\n                    this._isSync = true;\n                    return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n                }\n                finally {\n                    // We need to check the delegate is the same as entryFunction or not.\n                    // Consider the following case.\n                    //\n                    // asyncTestZone.run(() => { // Here the delegate will be the entryFunction\n                    //   Zone.current.run(() => { // Here the delegate will not be the entryFunction\n                    //   });\n                    // });\n                    //\n                    // We only want to check whether there are async tasks scheduled\n                    // for the entry function.\n                    if (this._isSync && this.entryFunction === delegate) {\n                        this._finishCallbackIfDone();\n                    }\n                }\n            };\n            AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                // Let the parent try to handle the error.\n                var result = parentZoneDelegate.handleError(targetZone, error);\n                if (result) {\n                    this.failCallback(error);\n                    this._alreadyErrored = true;\n                }\n                return false;\n            };\n            AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n                delegate.hasTask(target, hasTaskState);\n                // We should only trigger finishCallback when the target zone is the AsyncTestZone\n                // Consider the following cases.\n                //\n                // const childZone = asyncTestZone.fork({\n                //   name: 'child',\n                //   onHasTask: ...\n                // });\n                //\n                // So we have nested zones declared the onHasTask hook, in this case,\n                // the onHasTask will be triggered twice, and cause the finishCallbackIfDone()\n                // is also be invoked twice. So we need to only trigger the finishCallbackIfDone()\n                // when the current zone is the same as the target zone.\n                if (current !== target) {\n                    return;\n                }\n                if (hasTaskState.change == 'microTask') {\n                    this._pendingMicroTasks = hasTaskState.microTask;\n                    this._finishCallbackIfDone();\n                }\n                else if (hasTaskState.change == 'macroTask') {\n                    this._pendingMacroTasks = hasTaskState.macroTask;\n                    this._finishCallbackIfDone();\n                }\n            };\n            return AsyncTestZoneSpec;\n        }());\n        AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n    })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n    Zone.__load_patch('asynctest', function (global, Zone, api) {\n        /**\n         * Wraps a test function in an asynchronous test zone. The test will automatically\n         * complete when all asynchronous calls within this zone are done.\n         */\n        Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n            // If we're running using the Jasmine test framework, adapt to call the 'done'\n            // function when asynchronous activity is finished.\n            if (global.jasmine) {\n                // Not using an arrow function to preserve context passed from call site\n                return function (done) {\n                    if (!done) {\n                        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                        // fake it here and assume sync.\n                        done = function () { };\n                        done.fail = function (e) {\n                            throw e;\n                        };\n                    }\n                    runInTestZone(fn, this, done, function (err) {\n                        if (typeof err === 'string') {\n                            return done.fail(new Error(err));\n                        }\n                        else {\n                            done.fail(err);\n                        }\n                    });\n                };\n            }\n            // Otherwise, return a promise which will resolve when asynchronous activity\n            // is finished. This will be correctly consumed by the Mocha framework with\n            // it('...', async(myFn)); or can be used in a custom framework.\n            // Not using an arrow function to preserve context passed from call site\n            return function () {\n                var _this = this;\n                return new Promise(function (finishCallback, failCallback) {\n                    runInTestZone(fn, _this, finishCallback, failCallback);\n                });\n            };\n        };\n        function runInTestZone(fn, context, finishCallback, failCallback) {\n            var currentZone = Zone.current;\n            var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n            if (AsyncTestZoneSpec === undefined) {\n                throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/plugins/async-test');\n            }\n            var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n            if (!ProxyZoneSpec) {\n                throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/plugins/proxy');\n            }\n            var proxyZoneSpec = ProxyZoneSpec.get();\n            ProxyZoneSpec.assertPresent();\n            // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n            // If we do it in ProxyZone then we will get to infinite recursion.\n            var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n            var previousDelegate = proxyZoneSpec.getDelegate();\n            proxyZone.parent.run(function () {\n                var testZoneSpec = new AsyncTestZoneSpec(function () {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's\n                        // still this one. Otherwise, assume\n                        // it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(function () {\n                        finishCallback();\n                    });\n                }, function (error) {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(function () {\n                        failCallback(error);\n                    });\n                }, 'test');\n                proxyZoneSpec.setDelegate(testZoneSpec);\n                testZoneSpec.patchPromiseForTest();\n            });\n            return Zone.current.runGuarded(fn, context);\n        }\n    });\n    (function (global) {\n        var OriginalDate = global.Date;\n        // Since when we compile this file to `es2015`, and if we define\n        // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n        // there will be an error which is `Cannot assign to read only property 'prototype'`\n        // so we need to use function implementation here.\n        function FakeDate() {\n            if (arguments.length === 0) {\n                var d = new OriginalDate();\n                d.setTime(FakeDate.now());\n                return d;\n            }\n            else {\n                var args = Array.prototype.slice.call(arguments);\n                return new (OriginalDate.bind.apply(OriginalDate, __spreadArray([void 0], args, false)))();\n            }\n        }\n        FakeDate.now = function () {\n            var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n            if (fakeAsyncTestZoneSpec) {\n                return fakeAsyncTestZoneSpec.getFakeSystemTime();\n            }\n            return OriginalDate.now.apply(this, arguments);\n        };\n        FakeDate.UTC = OriginalDate.UTC;\n        FakeDate.parse = OriginalDate.parse;\n        // keep a reference for zone patched timer function\n        var timers = {\n            setTimeout: global.setTimeout,\n            setInterval: global.setInterval,\n            clearTimeout: global.clearTimeout,\n            clearInterval: global.clearInterval\n        };\n        var Scheduler = /** @class */ (function () {\n            function Scheduler() {\n                // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n                this._schedulerQueue = [];\n                // Current simulated time in millis.\n                this._currentTickTime = 0;\n                // Current fake system base time in millis.\n                this._currentFakeBaseSystemTime = OriginalDate.now();\n                // track requeuePeriodicTimer\n                this._currentTickRequeuePeriodicEntries = [];\n            }\n            Scheduler.prototype.getCurrentTickTime = function () {\n                return this._currentTickTime;\n            };\n            Scheduler.prototype.getFakeSystemTime = function () {\n                return this._currentFakeBaseSystemTime + this._currentTickTime;\n            };\n            Scheduler.prototype.setFakeBaseSystemTime = function (fakeBaseSystemTime) {\n                this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n            };\n            Scheduler.prototype.getRealSystemTime = function () {\n                return OriginalDate.now();\n            };\n            Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n                options = __assign({\n                    args: [],\n                    isPeriodic: false,\n                    isRequestAnimationFrame: false,\n                    id: -1,\n                    isRequeuePeriodic: false\n                }, options);\n                var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n                var endTime = this._currentTickTime + delay;\n                // Insert so that scheduler queue remains sorted by end time.\n                var newEntry = {\n                    endTime: endTime,\n                    id: currentId,\n                    func: cb,\n                    args: options.args,\n                    delay: delay,\n                    isPeriodic: options.isPeriodic,\n                    isRequestAnimationFrame: options.isRequestAnimationFrame\n                };\n                if (options.isRequeuePeriodic) {\n                    this._currentTickRequeuePeriodicEntries.push(newEntry);\n                }\n                var i = 0;\n                for (; i < this._schedulerQueue.length; i++) {\n                    var currentEntry = this._schedulerQueue[i];\n                    if (newEntry.endTime < currentEntry.endTime) {\n                        break;\n                    }\n                }\n                this._schedulerQueue.splice(i, 0, newEntry);\n                return currentId;\n            };\n            Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n                for (var i = 0; i < this._schedulerQueue.length; i++) {\n                    if (this._schedulerQueue[i].id == id) {\n                        this._schedulerQueue.splice(i, 1);\n                        break;\n                    }\n                }\n            };\n            Scheduler.prototype.removeAll = function () {\n                this._schedulerQueue = [];\n            };\n            Scheduler.prototype.getTimerCount = function () {\n                return this._schedulerQueue.length;\n            };\n            Scheduler.prototype.tickToNext = function (step, doTick, tickOptions) {\n                if (step === void 0) { step = 1; }\n                if (this._schedulerQueue.length < step) {\n                    return;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var targetTask = this._schedulerQueue[step - 1];\n                this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n            };\n            Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                var finalTime = this._currentTickTime + millis;\n                var lastCurrentTime = 0;\n                tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n                // we need to copy the schedulerQueue so nested timeout\n                // will not be wrongly called in the current tick\n                // https://github.com/angular/angular/issues/33799\n                var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ?\n                    this._schedulerQueue :\n                    this._schedulerQueue.slice();\n                if (schedulerQueue.length === 0 && doTick) {\n                    doTick(millis);\n                    return;\n                }\n                while (schedulerQueue.length > 0) {\n                    // clear requeueEntries before each loop\n                    this._currentTickRequeuePeriodicEntries = [];\n                    var current = schedulerQueue[0];\n                    if (finalTime < current.endTime) {\n                        // Done processing the queue since it's sorted by endTime.\n                        break;\n                    }\n                    else {\n                        // Time to run scheduled function. Remove it from the head of queue.\n                        var current_1 = schedulerQueue.shift();\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            var idx = this._schedulerQueue.indexOf(current_1);\n                            if (idx >= 0) {\n                                this._schedulerQueue.splice(idx, 1);\n                            }\n                        }\n                        lastCurrentTime = this._currentTickTime;\n                        this._currentTickTime = current_1.endTime;\n                        if (doTick) {\n                            doTick(this._currentTickTime - lastCurrentTime);\n                        }\n                        var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTickTime] : current_1.args);\n                        if (!retval) {\n                            // Uncaught exception in the current scheduled function. Stop processing the queue.\n                            break;\n                        }\n                        // check is there any requeue periodic entry is added in\n                        // current loop, if there is, we need to add to current loop\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                                var i = 0;\n                                for (; i < schedulerQueue.length; i++) {\n                                    var currentEntry = schedulerQueue[i];\n                                    if (newEntry.endTime < currentEntry.endTime) {\n                                        break;\n                                    }\n                                }\n                                schedulerQueue.splice(i, 0, newEntry);\n                            });\n                        }\n                    }\n                }\n                lastCurrentTime = this._currentTickTime;\n                this._currentTickTime = finalTime;\n                if (doTick) {\n                    doTick(this._currentTickTime - lastCurrentTime);\n                }\n            };\n            Scheduler.prototype.flushOnlyPendingTimers = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick, { processNewMacroTasksSynchronously: false });\n                return this._currentTickTime - startTime;\n            };\n            Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n                if (limit === void 0) { limit = 20; }\n                if (flushPeriodic === void 0) { flushPeriodic = false; }\n                if (flushPeriodic) {\n                    return this.flushPeriodic(doTick);\n                }\n                else {\n                    return this.flushNonPeriodic(limit, doTick);\n                }\n            };\n            Scheduler.prototype.flushPeriodic = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick);\n                return this._currentTickTime - startTime;\n            };\n            Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n                var startTime = this._currentTickTime;\n                var lastCurrentTime = 0;\n                var count = 0;\n                while (this._schedulerQueue.length > 0) {\n                    count++;\n                    if (count > limit) {\n                        throw new Error('flush failed after reaching the limit of ' + limit +\n                            ' tasks. Does your code use a polling timeout?');\n                    }\n                    // flush only non-periodic timers.\n                    // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n                    if (this._schedulerQueue.filter(function (task) { return !task.isPeriodic && !task.isRequestAnimationFrame; })\n                        .length === 0) {\n                        break;\n                    }\n                    var current = this._schedulerQueue.shift();\n                    lastCurrentTime = this._currentTickTime;\n                    this._currentTickTime = current.endTime;\n                    if (doTick) {\n                        // Update any secondary schedulers like Jasmine mock Date.\n                        doTick(this._currentTickTime - lastCurrentTime);\n                    }\n                    var retval = current.func.apply(global, current.args);\n                    if (!retval) {\n                        // Uncaught exception in the current scheduled function. Stop processing the queue.\n                        break;\n                    }\n                }\n                return this._currentTickTime - startTime;\n            };\n            return Scheduler;\n        }());\n        // Next scheduler id.\n        Scheduler.nextId = 1;\n        var FakeAsyncTestZoneSpec = /** @class */ (function () {\n            function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n                if (trackPendingRequestAnimationFrame === void 0) { trackPendingRequestAnimationFrame = false; }\n                this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n                this.macroTaskOptions = macroTaskOptions;\n                this._scheduler = new Scheduler();\n                this._microtasks = [];\n                this._lastError = null;\n                this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n                this.patchDateLocked = false;\n                this.properties = { 'FakeAsyncTestZoneSpec': this };\n                this.name = 'fakeAsyncTestZone for ' + namePrefix;\n                // in case user can't access the construction of FakeAsyncTestSpec\n                // user can also define macroTaskOptions by define a global variable.\n                if (!this.macroTaskOptions) {\n                    this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n                }\n            }\n            FakeAsyncTestZoneSpec.assertInZone = function () {\n                if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n                var _this = this;\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    fn.apply(global, args);\n                    if (_this._lastError === null) { // Success\n                        if (completers.onSuccess != null) {\n                            completers.onSuccess.apply(global);\n                        }\n                        // Flush microtasks only on success.\n                        _this.flushMicrotasks();\n                    }\n                    else { // Failure\n                        if (completers.onError != null) {\n                            completers.onError.apply(global);\n                        }\n                    }\n                    // Return true if there were no errors, false otherwise.\n                    return _this._lastError === null;\n                };\n            };\n            FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n                var index = timers.indexOf(id);\n                if (index > -1) {\n                    timers.splice(index, 1);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n                var _this = this;\n                return function () {\n                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n                var _this = this;\n                return function () {\n                    // Requeue the timer callback if it's not been canceled.\n                    if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                        _this._scheduler.scheduleFunction(fn, interval, { args: args, isPeriodic: true, id: id, isRequeuePeriodic: true });\n                    }\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n                var _this = this;\n                return function () {\n                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n                if (isTimer === void 0) { isTimer = true; }\n                var removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n                // Queue the callback and dequeue the timer on success and error.\n                var cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n                var id = this._scheduler.scheduleFunction(cb, delay, { args: args, isRequestAnimationFrame: !isTimer });\n                if (isTimer) {\n                    this.pendingTimers.push(id);\n                }\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n                var id = Scheduler.nextId;\n                var completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n                var cb = this._fnAndFlush(fn, completers);\n                // Use the callback created above to requeue on success.\n                completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n                // Queue the callback and dequeue the periodic timer only on error.\n                this._scheduler.scheduleFunction(cb, interval, { args: args, isPeriodic: true });\n                this.pendingPeriodicTimers.push(id);\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n                var error = this._lastError || this._uncaughtPromiseErrors[0];\n                this._uncaughtPromiseErrors.length = 0;\n                this._lastError = null;\n                throw error;\n            };\n            FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {\n                return this._scheduler.getCurrentTickTime();\n            };\n            FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {\n                return this._scheduler.getFakeSystemTime();\n            };\n            FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {\n                this._scheduler.setFakeBaseSystemTime(realTime);\n            };\n            FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {\n                return this._scheduler.getRealSystemTime();\n            };\n            FakeAsyncTestZoneSpec.patchDate = function () {\n                if (!!global[Zone.__symbol__('disableDatePatching')]) {\n                    // we don't want to patch global Date\n                    // because in some case, global Date\n                    // is already being patched, we need to provide\n                    // an option to let user still use their\n                    // own version of Date.\n                    return;\n                }\n                if (global['Date'] === FakeDate) {\n                    // already patched\n                    return;\n                }\n                global['Date'] = FakeDate;\n                FakeDate.prototype = OriginalDate.prototype;\n                // try check and reset timers\n                // because jasmine.clock().install() may\n                // have replaced the global timer\n                FakeAsyncTestZoneSpec.checkTimerPatch();\n            };\n            FakeAsyncTestZoneSpec.resetDate = function () {\n                if (global['Date'] === FakeDate) {\n                    global['Date'] = OriginalDate;\n                }\n            };\n            FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n                if (global.setTimeout !== timers.setTimeout) {\n                    global.setTimeout = timers.setTimeout;\n                    global.clearTimeout = timers.clearTimeout;\n                }\n                if (global.setInterval !== timers.setInterval) {\n                    global.setInterval = timers.setInterval;\n                    global.clearInterval = timers.clearInterval;\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n                this.patchDateLocked = true;\n                FakeAsyncTestZoneSpec.patchDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n                this.patchDateLocked = false;\n                FakeAsyncTestZoneSpec.resetDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {\n                if (steps === void 0) { steps = 1; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                if (steps <= 0) {\n                    return;\n                }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tickToNext(steps, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tick(millis, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n                var _this = this;\n                FakeAsyncTestZoneSpec.assertInZone();\n                var flushErrors = function () {\n                    if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n                        // If there is an error stop processing the microtask queue and rethrow the error.\n                        _this._resetLastErrorAndThrow();\n                    }\n                };\n                while (this._microtasks.length > 0) {\n                    var microtask = this._microtasks.shift();\n                    microtask.func.apply(microtask.target, microtask.args);\n                }\n                flushErrors();\n            };\n            FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this._scheduler.removeAll();\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n            };\n            FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {\n                return this._scheduler.getTimerCount() + this._microtasks.length;\n            };\n            FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                switch (task.type) {\n                    case 'microTask':\n                        var args = task.data && task.data.args;\n                        // should pass additional arguments to callback if have any\n                        // currently we know process.nextTick will have such additional\n                        // arguments\n                        var additionalArgs = void 0;\n                        if (args) {\n                            var callbackIndex = task.data.cbIdx;\n                            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                            }\n                        }\n                        this._microtasks.push({\n                            func: task.invoke,\n                            args: additionalArgs,\n                            target: task.data && task.data.target\n                        });\n                        break;\n                    case 'macroTask':\n                        switch (task.source) {\n                            case 'setTimeout':\n                                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'setImmediate':\n                                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                                break;\n                            case 'setInterval':\n                                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'XMLHttpRequest.send':\n                                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                                    task.data['url']);\n                            case 'requestAnimationFrame':\n                            case 'webkitRequestAnimationFrame':\n                            case 'mozRequestAnimationFrame':\n                                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                                // (60 frames per second)\n                                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                                break;\n                            default:\n                                // user can define which macroTask they want to support by passing\n                                // macroTaskOptions\n                                var macroTaskOption = this.findMacroTaskOption(task);\n                                if (macroTaskOption) {\n                                    var args_1 = task.data && task.data['args'];\n                                    var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                                    var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n                                    if (!!macroTaskOption.isPeriodic) {\n                                        // periodic macroTask, use setInterval to simulate\n                                        task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                        task.data.isPeriodic = true;\n                                    }\n                                    else {\n                                        // not periodic, use setTimeout to simulate\n                                        task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                                    }\n                                    break;\n                                }\n                                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                        }\n                        break;\n                    case 'eventTask':\n                        task = delegate.scheduleTask(target, task);\n                        break;\n                }\n                return task;\n            };\n            FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                switch (task.source) {\n                    case 'setTimeout':\n                    case 'requestAnimationFrame':\n                    case 'webkitRequestAnimationFrame':\n                    case 'mozRequestAnimationFrame':\n                        return this._clearTimeout(task.data['handleId']);\n                    case 'setInterval':\n                        return this._clearInterval(task.data['handleId']);\n                    default:\n                        // user can define which macroTask they want to support by passing\n                        // macroTaskOptions\n                        var macroTaskOption = this.findMacroTaskOption(task);\n                        if (macroTaskOption) {\n                            var handleId = task.data['handleId'];\n                            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :\n                                this._clearTimeout(handleId);\n                        }\n                        return delegate.cancelTask(target, task);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n                try {\n                    FakeAsyncTestZoneSpec.patchDate();\n                    return delegate.invoke(target, callback, applyThis, applyArgs, source);\n                }\n                finally {\n                    if (!this.patchDateLocked) {\n                        FakeAsyncTestZoneSpec.resetDate();\n                    }\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n                if (!this.macroTaskOptions) {\n                    return null;\n                }\n                for (var i = 0; i < this.macroTaskOptions.length; i++) {\n                    var macroTaskOption = this.macroTaskOptions[i];\n                    if (macroTaskOption.source === task.source) {\n                        return macroTaskOption;\n                    }\n                }\n                return null;\n            };\n            FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                this._lastError = error;\n                return false; // Don't propagate error to parent zone.\n            };\n            return FakeAsyncTestZoneSpec;\n        }());\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n    })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n    Zone.__load_patch('fakeasync', function (global, Zone, api) {\n        var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n        function getProxyZoneSpec() {\n            return Zone && Zone['ProxyZoneSpec'];\n        }\n        var _fakeAsyncTestZoneSpec = null;\n        /**\n         * Clears out the shared fake async zone for a test.\n         * To be called in a global `beforeEach`.\n         *\n         * @experimental\n         */\n        function resetFakeAsyncZone() {\n            if (_fakeAsyncTestZoneSpec) {\n                _fakeAsyncTestZoneSpec.unlockDatePatch();\n            }\n            _fakeAsyncTestZoneSpec = null;\n            // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n            getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n        }\n        /**\n         * Wraps a function to be executed in the fakeAsync zone:\n         * - microtasks are manually executed by calling `flushMicrotasks()`,\n         * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n         *\n         * If there are any pending timers at the end of the function, an exception will be thrown.\n         *\n         * Can be used to wrap inject() calls.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @param fn\n         * @returns The function wrapped to be executed in the fakeAsync zone\n         *\n         * @experimental\n         */\n        function fakeAsync(fn) {\n            // Not using an arrow function to preserve context passed from call site\n            var fakeAsyncFn = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var ProxyZoneSpec = getProxyZoneSpec();\n                if (!ProxyZoneSpec) {\n                    throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                        'Please make sure that your environment includes zone.js/plugins/proxy');\n                }\n                var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n                if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                try {\n                    // in case jasmine.clock init a fakeAsyncTestZoneSpec\n                    if (!_fakeAsyncTestZoneSpec) {\n                        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                            throw new Error('fakeAsync() calls can not be nested');\n                        }\n                        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n                    }\n                    var res = void 0;\n                    var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n                    proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n                    _fakeAsyncTestZoneSpec.lockDatePatch();\n                    try {\n                        res = fn.apply(this, args);\n                        flushMicrotasks();\n                    }\n                    finally {\n                        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                        throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length, \" \") +\n                            \"periodic timer(s) still in the queue.\");\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                        throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingTimers.length, \" timer(s) still in the queue.\"));\n                    }\n                    return res;\n                }\n                finally {\n                    resetFakeAsyncZone();\n                }\n            };\n            fakeAsyncFn.isFakeAsync = true;\n            return fakeAsyncFn;\n        }\n        function _getFakeAsyncZoneSpec() {\n            if (_fakeAsyncTestZoneSpec == null) {\n                _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (_fakeAsyncTestZoneSpec == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            }\n            return _fakeAsyncTestZoneSpec;\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n         *\n         * The microtasks queue is drained at the very start of this function and after any timer callback\n         * has been executed.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @experimental\n         */\n        function tick(millis, ignoreNestedTimeout) {\n            if (millis === void 0) { millis = 0; }\n            if (ignoreNestedTimeout === void 0) { ignoreNestedTimeout = false; }\n            _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n         * draining the macrotask queue until it is empty. The returned value is the milliseconds\n         * of time that would have been elapsed.\n         *\n         * @param maxTurns\n         * @returns The simulated time elapsed, in millis.\n         *\n         * @experimental\n         */\n        function flush(maxTurns) {\n            return _getFakeAsyncZoneSpec().flush(maxTurns);\n        }\n        /**\n         * Discard all remaining periodic tasks.\n         *\n         * @experimental\n         */\n        function discardPeriodicTasks() {\n            var zoneSpec = _getFakeAsyncZoneSpec();\n            zoneSpec.pendingPeriodicTimers;\n            zoneSpec.pendingPeriodicTimers.length = 0;\n        }\n        /**\n         * Flush any pending microtasks.\n         *\n         * @experimental\n         */\n        function flushMicrotasks() {\n            _getFakeAsyncZoneSpec().flushMicrotasks();\n        }\n        Zone[api.symbol('fakeAsyncTest')] =\n            { resetFakeAsyncZone: resetFakeAsyncZone, flushMicrotasks: flushMicrotasks, discardPeriodicTasks: discardPeriodicTasks, tick: tick, flush: flush, fakeAsync: fakeAsync };\n    }, true);\n    /**\n     * Promise for async/fakeAsync zoneSpec test\n     * can support async operation which not supported by zone.js\n     * such as\n     * it ('test jsonp in AsyncZone', async() => {\n     *   new Promise(res => {\n     *     jsonp(url, (data) => {\n     *       // success callback\n     *       res(data);\n     *     });\n     *   }).then((jsonpResult) => {\n     *     // get jsonp result.\n     *\n     *     // user will expect AsyncZoneSpec wait for\n     *     // then, but because jsonp is not zone aware\n     *     // AsyncZone will finish before then is called.\n     *   });\n     * });\n     */\n    Zone.__load_patch('promisefortest', function (global, Zone, api) {\n        var symbolState = api.symbol('state');\n        var UNRESOLVED = null;\n        var symbolParentUnresolved = api.symbol('parentUnresolved');\n        // patch Promise.prototype.then to keep an internal\n        // number for tracking unresolved chained promise\n        // we will decrease this number when the parent promise\n        // being resolved/rejected and chained promise was\n        // scheduled as a microTask.\n        // so we can know such kind of chained promise still\n        // not resolved in AsyncTestZone\n        Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                return;\n            }\n            oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n            Promise.prototype.then = function () {\n                var chained = oriThen.apply(this, arguments);\n                if (this[symbolState] === UNRESOLVED) {\n                    // parent promise is unresolved.\n                    var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n                    if (asyncTestZoneSpec) {\n                        asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n                        chained[symbolParentUnresolved] = true;\n                    }\n                }\n                return chained;\n            };\n        };\n        Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n            // restore origin then\n            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                Promise.prototype.then = oriThen;\n                Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n            }\n        };\n    });\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}